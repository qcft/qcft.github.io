[{"title":"记Mousetarck的一些技术尝试","url":"/2019/08/15/some-way-to-deal-mouse-track/","content":"<p><img src=\"https://p5.ssl.qhimg.com/t01771478e667255d55.png\" alt=\"mousetrack_img\"></p>\n<h3 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h3><p>为了统计分析用户页面行为，我们经常需要收集鼠标在页面上的各类操作，如页面中按钮和链接的点击和统计较准确的访客页面停留时间。而本文主要记录在解决<code>分别记录鼠标在页面各个区域的停留时间总和</code>这一问题的技术方案的尝试。</p>\n<p>简化问题描述：将浏览器的可视窗口平均分为2 × 2的4份， 如图。分别记录鼠标在各个区域的停留时间总和，当然，不能影响页面的正常功能的使用。</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01752acf18ecbe6aa7.png\" alt=\"页面区域示意\"></p>\n<p>当鼠标进入某块区域时开始计时， 移出时结束计时。那问题就在于如何判断鼠标的所在区域。</p>\n<p>于是， 自然就想到了通过鼠标的坐标来判断所处区域 。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution 1\"></a>Solution 1</h3><p>监听鼠标的mousemove事件， 获取鼠标的坐标(x, y),  根据它来判断鼠标当前处在哪个区域，然后累加当前区域的记录时间。</p>\n<p>此外， 需要对该事件的触发频率进行优化，避免触发频率过快，造成不必要的计算开销。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mouseTrack = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  fromEvent(<span class=\"built_in\">document</span>, <span class=\"string\">&#x27;mousemove&#x27;</span>)</span><br><span class=\"line\">    .pipe(debounceTime(sampleTime))</span><br><span class=\"line\">    .subscribe(<span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> &#123;  </span><br><span class=\"line\">      \t<span class=\"keyword\">const</span> &#123; clientX, clientY &#125; = e</span><br><span class=\"line\">        <span class=\"keyword\">let</span> currentPart : number = \t<span class=\"comment\">// 计算所在区域</span></span><br><span class=\"line\">          <span class=\"built_in\">Math</span>.floor(clientX / unitWidth) + </span><br><span class=\"line\">          n * <span class=\"built_in\">Math</span>.floor(clientY / unitHeight);</span><br><span class=\"line\"> </span><br><span class=\"line\">    \t<span class=\"keyword\">const</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">    \t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        \t  record[lastPart].duration += now - tick;</span><br><span class=\"line\">    \t&#125; <span class=\"keyword\">catch</span>(err) &#123;&#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        tick = now;</span><br><span class=\"line\">        lastPart = currentPart;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(record.map(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> v.duration));</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span></span><br><span class=\"line\"></span><br><span class=\"line\">问题似乎就这样愉快的被解决了！</span><br><span class=\"line\"></span><br><span class=\"line\">但是经过一番测试之后， 发现了一些不足的地方。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 页面加载后， 若鼠标一直不动， 则无法触发事件，进而无法判断所在区域（疑无解）</span><br><span class=\"line\">+ 当用户以较快的速度移动，有时导致统计的时间和所在区域对应错误（统计的准确性有待提高）</span><br><span class=\"line\">+ 实际需要统计的区域肯定不是简单均分页面的<span class=\"number\">4</span>块区域， 实际判断鼠标所在区域的计算会更复杂</span><br><span class=\"line\"></span><br><span class=\"line\">对于mousemove这类触发频繁的事件， 在其他如drag， <span class=\"built_in\">window</span> resize， scroll的场景下，可以使用函数节流、防抖等操作优化执行频率，且无明显副作用。但在此需求下，如果时间间隔过大，统计的准确性明显下降，如果时间间隔太小甚至不对触发频率进行限制， 而增加的性能开销也不是我们想要的。</span><br><span class=\"line\"></span><br><span class=\"line\">难道，就秉持中庸之道， 取个中间值？</span><br><span class=\"line\"></span><br><span class=\"line\">后期也了解到通过分析搜集海量的这种统计数据， 清洗极端数据， 一通分析之后，也可以得到较准确的结果。单纯的收集鼠标在某个区域的时间意义不大， 主要还是通过海量的数据搜集分析， 进而了解用户在页面上行为、喜好、热点区域等。</span><br><span class=\"line\"></span><br><span class=\"line\">道理是都懂，但是作为一个优秀的程序员， 总是想在自己的一亩三分地写出更好的代码，能不能提供比较准确的数据，又不会产生较大的性能开销？</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### Solution 2</span><br><span class=\"line\"></span><br><span class=\"line\">上述方式需要频繁的触发事件， 主要是为了获取鼠标当前所在区域， 那我就在统计区域上加个透明div, 当div的<span class=\"string\">`mouseenter`</span>事件触发时，开始计时， 触发<span class=\"string\">`mouseleave`</span>时， 结束计时。加上后，发现由于div的遮盖， 页面中的各类按钮，链接都无法触发。这肯定不行， 又查了一下事件穿透， get了[pointer-events](https:<span class=\"comment\">//www.w3.org/TR/SVG/interact.html#PointerEventsProperty)属性.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`pointer-events`</span>可以禁用鼠标事件， 允许事件穿透，常用的属性值(auto / none), 其他属性值只适用于svg元素</span><br><span class=\"line\"></span><br><span class=\"line\">愉快的加上该属性， 发现透明div的mouseenter/mouseleave事件也被禁止，无法触发了......</span><br><span class=\"line\"></span><br><span class=\"line\">稳住心态，思索了一下</span><br><span class=\"line\"></span><br><span class=\"line\">![pointer-evnets](https:<span class=\"comment\">//p3.ssl.qhimg.com/t012d3f90a084507415.png)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>鼠标首次移动：<br>    记录开始时间<br>    当前所在区域 pointer-events: none;<br>某一区域触发mouseenter事件：<br>    该区域变成 pointer-events: none;<br>    原来区域 pointer-events: all;<br>    记录原区域的停留时间<br>    记录进入新区域的时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">鼠标当前所在的透明的div区域处于事件穿透状态， 其他区域被div正常覆盖，当鼠标移入其他区域时， 移入区域变成事件穿透状态(页面的链接、按钮等功能正常)， 原来区域还原。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">通过这种方式，可以较好的解决上面的问题</span><br><span class=\"line\"></span><br><span class=\"line\">+ 不用mousemove这种频繁触发的事件，节省了额外的开销</span><br><span class=\"line\"></span><br><span class=\"line\">+ 只要鼠标的移动速度在浏览器的捕获范围内， 它在不同区域之间的切换都能很好的触发事件， 大大提供了统计数据的准确性</span><br><span class=\"line\"></span><br><span class=\"line\">不足：</span><br><span class=\"line\"></span><br><span class=\"line\">+ pointer-events的兼容性， 兼容到 IE11 (硬伤)</span><br><span class=\"line\"></span><br><span class=\"line\">还有一点瑕疵，就是鼠标在不同区域移动时， 需要操作div的pointer-events属性在all和none之间切换， 且在非鼠标所在区域，透明div是遮挡页面鼠标的各种事件的。能不能不让它遮挡呢？</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### Solution 3</span><br><span class=\"line\"></span><br><span class=\"line\">其实，是看中了pointer-events的&#96;stroke&#96;属性值， 利用它， 可以使得在元素**内部**事件穿透， 在元素**边框**触发事件，极好的满足了我的诉求,  由于该属性只在SVG下生效，于是将透明div换成了SVG元素。</span><br><span class=\"line\"></span><br><span class=\"line\">![pointer-events-border](https:&#x2F;&#x2F;p0.ssl.qhimg.com&#x2F;t01d62897a2fba37bbe.png)</span><br><span class=\"line\"></span><br><span class=\"line\">实际测试一番后发现，要以较慢的速度移动鼠标，才会触发SVG边框的事件，稍快移动鼠标， 边框就无法捕捉事件。由于边框的宽度有限， 移动太快， 就超出了浏览器的捕捉极限。之后又试着增大了边框的宽度， 但效果变化不是很明显。</span><br><span class=\"line\"></span><br><span class=\"line\">感觉有点奇怪， 于是新建一个测试页面，监听一个边框为1px的div，在我的手速极限内， &#96;mouseenter&#96;事件正常触发。但是在svg里面为什么触发比较艰难呢？</span><br><span class=\"line\"></span><br><span class=\"line\">是浏览器的极限就是这样，还是我写的SVG有问题？一直没有解决这个问题，欢迎大家指教 。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;javascript</span><br><span class=\"line\">const drawsvg &#x3D; function() &#123;</span><br><span class=\"line\">    const svgns &#x3D; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot;; </span><br><span class=\"line\">    let svg &#x3D; document.createElementNS(svgns, &quot;svg&quot;); </span><br><span class=\"line\">    svg.setAttribute(); &#x2F;&#x2F; other attribute</span><br><span class=\"line\">    svg.setAttribute(&quot;style&quot;, &quot;pointer-events: none;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    let polygon &#x3D; document.createElementNS(svgns, &quot;polygon&quot;);</span><br><span class=\"line\">    polygon.setAttribute(); &#x2F;&#x2F; other attribute</span><br><span class=\"line\">    polygon.setAttribute(&quot;style&quot;, &quot;pointer-events: stroke;&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    svg.appendChild(polygon);</span><br><span class=\"line\">    document.body.appendChild(svg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>本篇文章主要记录在解决<strong>记录鼠标在页面各个区域的停留时间总和</strong>这一需求时的实现方式的尝试和解决相应问题的进一步尝试。现阶段，选择的是方案二和方案一组合使用，在满足pointer-events属性的兼容性情况下，使用方案二， 退之， 则使用第一种方案。</p>\n<p><em>如文章有任何bug，欢迎指出</em>！</p>\n","categories":["前端"],"tags":["Javascript","Mousetarck"]},{"title":"WEB验证的过去现在与未来","url":"/2019/08/29/web-authentication-time/","content":"<p><img src=\"https://p1.ssl.qhimg.com/t0159cbba79e1dd5740.png\"></p>\n<blockquote>\n<p>本文作者：韩永刚，360奇舞团 前端开发工程师。</p>\n</blockquote>\n<p>本文将以时间维度介绍一些目前常见的Web验证方法以及相关协议，带你了解Web验证的过去、现在与未来。</p>\n<h2 id=\"传统身份验证方式\"><a href=\"#传统身份验证方式\" class=\"headerlink\" title=\"传统身份验证方式\"></a>传统身份验证方式</h2><p><img src=\"https://p1.ssl.qhimg.com/t01e5be0ec30c7e5009.jpg\"></p>\n<h3 id=\"过去普遍的做法可能是这样的\"><a href=\"#过去普遍的做法可能是这样的\" class=\"headerlink\" title=\"过去普遍的做法可能是这样的\"></a>过去普遍的做法可能是这样的</h3><h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><ul>\n<li><p>前端注册页面填写用户名和密码表单，发送给后台服务器</p>\n</li>\n<li><p>后台服务器将接收到的用户名和密码进行加密并插入到数据库，然后回馈是否成功的信息给前端页面。</p>\n<a id=\"more\"></a>\n<h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4></li>\n<li><p>前端登录页面填写用户名和密码表单，发送给后台服务器</p>\n</li>\n<li><p>后台服务器将接收到的用户名和密码进行加密后与数据库储存信息进行对比，如果账号密码一致则返回给前端登录成功信息，不一致则返回失败信息。</p>\n</li>\n</ul>\n<h3 id=\"这种做法存在普遍问题\"><a href=\"#这种做法存在普遍问题\" class=\"headerlink\" title=\"这种做法存在普遍问题\"></a>这种做法存在普遍问题</h3><ul>\n<li>当登录环境不安全时，输入密码时可能被监控</li>\n<li>发送密码到服务器的过程中可能被劫持</li>\n<li>密码存储在数据库如果被黑客攻击可能造成大量密码泄露</li>\n</ul>\n<h3 id=\"这种做法最大的问题在于你需要输入密码\"><a href=\"#这种做法最大的问题在于你需要输入密码\" class=\"headerlink\" title=\"这种做法最大的问题在于你需要输入密码\"></a>这种做法最大的问题在于你需要输入密码</h3><ul>\n<li>人们通常使用一个密码应对所有账号，而攻击者获取密码的方式又数不胜数，一旦在某个疏于防备的瞬间泄露了一个密码，那么该用户所有账号都将面临巨大安全风险</li>\n</ul>\n<h2 id=\"第三方登录方式\"><a href=\"#第三方登录方式\" class=\"headerlink\" title=\"第三方登录方式\"></a>第三方登录方式</h2><p><img src=\"https://p1.ssl.qhimg.com/t014ac840ec7b5f0b01.png\"></p>\n<p>现在，越来越多的站点开放了第三方登录的功能，使得账号密码登录不再是唯一的身份验证方式，在可以进行第三方登录的站点，人们通常选择使用第三方登录的方式进行身份验证。<br>实现第三方登录有两种协议，分别为<strong>OpenID</strong>开放认证协议与<strong>OAuth</strong>开放授权协议</p>\n<p>OpenID和OAuth完全是为了两种不同的需求而生，OpenID的目标是为了帮助网站确认一个用户的身份 ，OAuth的目标是为了授权第三方在可控范围下访问用户资源，OAuth有两个版本，OAuth1.0由于其实现较为复杂，已经基本被OAuth2.0所取代，以下分别对两种协议进行讲解</p>\n<h3 id=\"OpenID-开放认证协议\"><a href=\"#OpenID-开放认证协议\" class=\"headerlink\" title=\"OpenID 开放认证协议\"></a>OpenID 开放认证协议</h3><p><img src=\"https://p3.ssl.qhimg.com/t0139fd55e5aade6e21.png\"></p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li>OpenID是一个<strong>去中心化</strong>的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册，比如Google。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。</li>\n<li>OpenID是专为登录认证而生，它使用简单，门槛很低。一个网站如果想要接入OpenID认证是非常简单的，不需要创建应用，不需要App Key，不需要Secret，只需要将用户导向OpenID Provider的Entry并带上Callback，用户只要同意提供信息，你就可以拿到这个用户的<strong>唯一标识</strong>。对于站点来说只要有人使用Google OpenID授权并返回这个<strong>唯一标识</strong>那就是我在登录。</li>\n</ul>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>使用门槛变低，免去注册流程，且用户不再需要输入密码，可直接使用第三方登录，有利于产品的广泛传播</li>\n<li>由于客户端不在需要输入密码，很大程度上减少了安全风险，客户端不接触用户密码，服务器端更易于集中保护</li>\n</ul>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>依赖开放平台的安全防护能力，因为开放平台本身也可能是使用账号密码登录或者其他第三方平台登录，所以开放平台本身也会出现一定的安全风险。如果开放平台本身出现安全问题，那么所有与其关联的第三方认证站点都将会出现安全问题</li>\n<li>依赖开放平台的认证，如果开放平台的稳定性不达标，会导致自身登录稳定性差。如第三方平台暂时不可用，则自身登录也不可用，如果开放平台恶意不给予认证，那么用户将无法登录，这个在较大的站点上是致命的。</li>\n<li>用户流失的风险，因为用户只记得是用第三方登录的，而往往不是该网站的帐号，弱化了自身账号的影响力。</li>\n</ul>\n<h3 id=\"OAuth2-0-开放授权协议\"><a href=\"#OAuth2-0-开放授权协议\" class=\"headerlink\" title=\"OAuth2.0 开放授权协议\"></a>OAuth2.0 开放授权协议</h3><p><img src=\"https://p2.ssl.qhimg.com/t01913628cf02f2f748.png\"></p>\n<h4 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li>提到OAuth，可以想像这样一幅画面，在一个炎热且忙碌的夏天，小明与妻子在公司不分昼夜的赶着项目，可家里又有老人需要照顾，所以小明决定请一个保姆照顾老人，但是又觉得如果保姆能在家里乱走的话很不放心，就授权给保姆一个只能打开老人房门且有效期仅为7天的临时密码凭证，之后一周内保姆拿着这个临时密码凭证便可以不经过小明同意随意出入老人房间，但不能进入小明和他妻子的房间。</li>\n<li>我们把上面的例子搬到互联网，就是 OAuth 的设计了，OAuth与OpenID最大的区别就是，OpenID是一种<strong>认证协议</strong>，是开放平台给第三方一个能够代表用户身份的唯一标识，而OAuth是一种<strong>授权协议</strong>。授权允许第三方直接从开放平台读取用户信息。</li>\n</ul>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ul>\n<li>使用门槛变低，免去注册流程，且用户不再需要输入密码，可直接使用第三方登录，有利于产品的广泛传播</li>\n<li>由于客户端不在需要输入密码，很大程度上减少了安全风险，客户端不接触用户密码，服务器端更易于集中保护</li>\n<li>客户可以具有不同的信任级别，级别越高，可获取资料越多</li>\n</ul>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ul>\n<li>依赖<strong>开放平台</strong>的安全防护能力，因为开放平台本身也可能是使用账号密码登录或者其他第三方平台登录，所以开放平台本身也会出现一定的安全风险。如果开放平台本身出现安全问题，那么所有与其关联的<strong>第三方认证站点</strong>都将会出现安全问题</li>\n<li>依赖<strong>开放平台</strong>的授权，如果开放平台的稳定性不达标，会导致自身登录稳定性差。如开放平台暂时不可用，则自身登录也不可用，如果开放平台恶意不给予授权，那么用户将无法登录，这个在较大的站点上是致命的。</li>\n<li>用户流失的风险，因为用户只记得是用第三方登录的，而往往不是该网站的帐号，弱化了自身账号的影响力。</li>\n<li>站点获取到开放平台用户的临时权限后利用这些权限来做什么完全由该站点决定，在一定程度上会带来<strong>安全隐患</strong>。</li>\n</ul>\n<h3 id=\"第三方登录总结\"><a href=\"#第三方登录总结\" class=\"headerlink\" title=\"第三方登录总结\"></a>第三方登录总结</h3><p>第三方登录简化了注册登录流程，用户在使用时大部分情况下都不需要输入账号密码来进行登录操作，但第三方登录依赖<strong>开放平台</strong>，开放平台依然需要进行账号密码的储存与管理，而且当开放平台出现安全事故时，所有通过该平台登录的站点都将面临安全风险。</p>\n<h2 id=\"2FA-双因素认证\"><a href=\"#2FA-双因素认证\" class=\"headerlink\" title=\"2FA 双因素认证\"></a>2FA 双因素认证</h2><p><img src=\"https://p4.ssl.qhimg.com/t01c90759732d296b10.png\"></p>\n<h3 id=\"什么是双因素认证\"><a href=\"#什么是双因素认证\" class=\"headerlink\" title=\"什么是双因素认证\"></a>什么是双因素认证</h3><ul>\n<li>双因素认证也叫<strong>二次验证</strong>就是指同时使用<strong>两种及以上</strong>能够证明自己身份的方式进行验证，双因素认证就是在使用用户名密码登录网站、应用、账号之后，还需要一个验证码才能正常登录。</li>\n<li>其实双因素认证早在十几年前就已经开始应用，诸如短信验证码、邮件验证码、动态令牌、RSA电子动态令牌等都属于双因素认证。各大网银广泛使用的各种盾、各种 Key 其实也属于双因素认证，包括短信验证码，它能够让用户的数据多一层保护。</li>\n</ul>\n<p><img src=\"https://p1.ssl.qhimg.com/t01bdde19456da2ec5c.png\"></p>\n<h3 id=\"常见的双因素认证方法\"><a href=\"#常见的双因素认证方法\" class=\"headerlink\" title=\"常见的双因素认证方法\"></a>常见的双因素认证方法</h3><ul>\n<li>第一种是<strong>短信验证</strong>，也是目前较为常用的，每一次认证时会生成短信验证码发送到指定手机上，输入的内容与发送的内容一致则完成认证。</li>\n<li>第二种是<strong>认证APP</strong>，基于TOTP的加密算法，利用应用与认证APP共同持有的种子密钥，每隔30秒生成一个新的6位验证码，应用与APP之间的验证码一致则完成验证，通常在公司内部使用的VPN就是采用这种方式来进行身份验证。</li>\n<li>第三种是<strong>登录确认</strong>的方式，这种方式不需要输入验证码，而是通过登录确认点击的方式来完成双因素认证的过程，这种方式是通过公钥加密算法来确认你的身份，应用会生成一个密钥对，私钥存储在本地，公钥发送给服务端作为用户信息存储，当用户进行登录操作时，服务端会用公钥加密一段信息发送到你的设备上，只有拥有正确私钥的设备才能解密并完成二次认证。</li>\n</ul>\n<h3 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>必须通过两种及以上的验证才能确认身份，安全性较高</li>\n</ul>\n<h3 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>使用门槛变高，登录多了一步，费时且麻烦，不有利于产品的广泛传播</li>\n<li>2FA 不意味着账户的绝对安全，入侵者依然可以通过克隆SIM卡、盗取cookie或token等方式进行攻击</li>\n<li>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</li>\n</ul>\n<h2 id=\"Web验证的未来-WebAuthn\"><a href=\"#Web验证的未来-WebAuthn\" class=\"headerlink\" title=\"Web验证的未来 WebAuthn\"></a>Web验证的未来 WebAuthn</h2><p><img src=\"https://p0.ssl.qhimg.com/t010396def4b1eaf4a8.png\"></p>\n<h3 id=\"WebAuthn是什么？\"><a href=\"#WebAuthn是什么？\" class=\"headerlink\" title=\"WebAuthn是什么？\"></a>WebAuthn是什么？</h3><ul>\n<li><strong>WebAuthn</strong>是由W3C万维网联盟发布的 Web 标准。WebAuthn 是FIDO联盟指导下的<strong>FIDO2</strong>项目的核心组成部分。WebAuthn的目标就是提供一系列标准化的协议，让用户告别过去繁琐且不安全的账号密码登录方式，以实现安全的<strong>无密登录体验</strong>为目的。</li>\n<li>WebAuthn 彻底抛弃了传统的账号密码登录方式，它允许用户直接使用设备的<strong>指纹识别</strong>、<strong>面部识别</strong>、<strong>虹膜识别</strong>、<strong>声音识别</strong>、<strong>实体密钥</strong>（USB连接、蓝牙连接、NFC连接）等方式来进行登录验证。</li>\n</ul>\n<h3 id=\"体验WebAuthn\"><a href=\"#体验WebAuthn\" class=\"headerlink\" title=\"体验WebAuthn\"></a>体验WebAuthn</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:&#x2F;&#x2F;demo.yubico.com&#x2F;webauthn-technical&#x2F;registration</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>windows 10 用户可以购买型号为<strong>yubikey 5 NFC</strong>版密钥，插入设备的USB接口后访问以上网址体验WebAuthn。</li>\n</ul>\n<p><img src=\"https://p4.ssl.qhimg.com/t01ae6112aec5a1654d.png\"></p>\n<ul>\n<li>有touch bar功能的macbook可以直接访问以上网址体验WebAuthn。</li>\n</ul>\n<p><img src=\"https://p1.ssl.qhimg.com/t013a51ad871beb6255.png\"></p>\n<ul>\n<li>iPhone 用户可以购买型号为<strong>yubikey 5 NFC</strong>版密钥，打开以上网址后将密钥放在手机背后通过密钥NFC的验证功能体验WebAuthn。</li>\n</ul>\n<p><img src=\"https://p2.ssl.qhimg.com/t010f9d928bad81b522.png\"></p>\n<ul>\n<li>安卓用户可以在手机开启GMS服务并升级Google Play为最新版后访问以上网址体验WebAuthn。</li>\n</ul>\n<p><img src=\"https://p1.ssl.qhimg.com/t012f8fe55e2c984c9c.png\"></p>\n<h3 id=\"优点-3\"><a href=\"#优点-3\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ul>\n<li>使用WebAuthn进行账号登录的安全性非常高</li>\n<li>即不需要输入密码，又不需要征求第三方授权，直接利用设备的生物识别功能，登录流程非常简单快速，有利于产品的广泛传播</li>\n</ul>\n<h3 id=\"缺点-3\"><a href=\"#缺点-3\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>目前还不成熟，国内大部分站点都不支持使用WebAuthn登录</li>\n</ul>\n<h3 id=\"WebAuthn学习资料\"><a href=\"#WebAuthn学习资料\" class=\"headerlink\" title=\"WebAuthn学习资料\"></a>WebAuthn学习资料</h3><ol>\n<li><p>想要快速了解WebAuthn可以参考我的PPT，并结合Demo源码来学习</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PPT：https:&#x2F;&#x2F;ppt.baomitu.com&#x2F;d&#x2F;129a784a</span><br><span class=\"line\">Demo源码：https:&#x2F;&#x2F;github.com&#x2F;hanyonggang&#x2F;WebAuthnDemo</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>有关WebAuthn详细用法，可以查阅W3C或MDN的官方文档。</p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>WebAuthn的无密登录体验无论在安全性方面还是在易用性方面都是未来更好的选择，预计在不久的将来有望成为主流的Web验证方式。也希望我们能够早日使用上这样的无密登录体验吧！</p>\n","categories":["前端"],"tags":["Javascript","WEB验证"]},{"title":"微信小程序工程化之持续集成方案","url":"/2019/10/31/wechat-ci/","content":"<p><img src=\"https://p1.ssl.qhimg.com/t0166864b2322539b1d.jpg\"></p>\n<blockquote>\n<p>本文作者：韩永刚，360奇舞团 WEB前端开发高级工程师。</p>\n</blockquote>\n<p>本文将简单介绍一下持续集成的概念，并手把手带你在你的微信小程序项目中完成属于你的持续集成方案。</p>\n<h1 id=\"什么是前端工程化\"><a href=\"#什么是前端工程化\" class=\"headerlink\" title=\"什么是前端工程化\"></a>什么是前端工程化</h1><p>所有能降低成本，并且能提高效率的事情总称为工程化。在前端项目中能够减少重复工作、扩展 javascript\\html\\css 本身的语言能力、解决功能复用和变更问题、解决开发和产品环境差异问题、任何时间任何地点生成可部署的软件、解决发布流程问题，都属于前端工程化。</p>\n<h1 id=\"什么是持续集成\"><a href=\"#什么是持续集成\" class=\"headerlink\" title=\"什么是持续集成\"></a>什么是持续集成</h1><p>持续集成是前端工程化中的一部分，是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括自动化编译，自动化测试，自动化发布）来验证项目代码，从而尽早地发现错误。</p>\n<a id=\"more\"></a>\n<h1 id=\"Web项目持续集成怎么做\"><a href=\"#Web项目持续集成怎么做\" class=\"headerlink\" title=\"Web项目持续集成怎么做\"></a>Web项目持续集成怎么做</h1><p>Web项目的持续集成方案选择比较多，并且相对成熟，这里介绍一下 <strong>gitlab-ci</strong> 持续集成方案。</p>\n<p>这种方式的原理就是为项目在自己的 <strong>linux</strong> 服务器安装并注册 <strong>gitlab-runner</strong> ，注册会有一个 <strong>token</strong> ，服务器上运行 <strong>gitlab-runner</strong> 后， <strong>runner</strong> 会轮询的发送带 <strong>token</strong> 的 <strong>http</strong> 请求给 <strong>gitlab</strong> ,如果 <strong>gitlab</strong> 有任务了，（一般是 <strong>git push</strong> ），那么会把任务信息返回给 <strong>runner</strong> ，然后 <strong>runner</strong> 就开始调用注册时选的 <strong>Executor</strong> 来执行项目根目录下的配置文件 <strong>.gitlab-ci.yml</strong> ，执行后把结果反馈给 <strong>gitlab</strong> 。</p>\n<p>此时我们可以编写 <strong>.gitlab-ci.yml</strong> 脚本，比如设定当 <strong>test</strong> 分支发生 <strong>push</strong> 时，自动运行测试用例、自动构建代码、自动将代码更新到测试人员在测的环境等任何你想在提测时需要做的事情。当 <strong>merge</strong> 到 <strong>master</strong> 时，自动更新线上代码完成上线等各种你想在上线时做的事情。</p>\n<p>这里只要考虑的足够全面，那么之后的项目开发你只需要 <strong>push</strong> 到对应的分支，<strong>gitlab-runner</strong> 会自动完成你想做的所有构建、提测、上线操作。减少重复工作，这就是持续集成的意义所在。</p>\n<h1 id=\"手把手教你完成小程序的持续集成方案\"><a href=\"#手把手教你完成小程序的持续集成方案\" class=\"headerlink\" title=\"手把手教你完成小程序的持续集成方案\"></a>手把手教你完成小程序的持续集成方案</h1><p>小程序的持续集成可以继续使用 <strong>gitlab-ci</strong> 的方式，但由于小程序的构建、提测、提交体验版等操作都需要依赖于 <strong>微信开发者工具</strong> ，而微信开发者工具只有 <strong>Windows</strong> 和 <strong>Mac</strong> 版，所以我们需要一台 <strong>Windows</strong> 服务器来运行 <strong>gitlab-runner</strong>。</p>\n<h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1. 准备工作\"></a>1. 准备工作</h2><ul>\n<li>一台 <strong>Windows</strong> 服务器</li>\n<li>一个权限为 <strong>Maintainer</strong> 的 <strong>gitlab</strong>项目</li>\n</ul>\n<h2 id=\"2-安装必要软件\"><a href=\"#2-安装必要软件\" class=\"headerlink\" title=\"2. 安装必要软件\"></a>2. 安装必要软件</h2><p>在这台 <strong>Windows</strong> 服务器上安装以下软件</p>\n<ul>\n<li><strong>Git</strong></li>\n<li><strong>Node.js</strong></li>\n<li><strong>微信开发者工具</strong></li>\n</ul>\n<h2 id=\"3-配置gitlab-runner\"><a href=\"#3-配置gitlab-runner\" class=\"headerlink\" title=\"3. 配置gitlab-runner\"></a>3. 配置gitlab-runner</h2><ol>\n<li><p>首先下载 <strong>gitlab-runner</strong></p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vcnVubmVyL2luc3RhbGwvd2luZG93cy5odG1s\">https://docs.gitlab.com/runner/install/windows.html<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<p>下载完成后将其移动到合适的路径后重命名为 <strong>gitlab-runner.exe</strong></p>\n</li>\n<li><p>在 <strong>Windows</strong> 服务器中打开 <strong>powershell</strong> 并进入 <strong>gitlab-runner.exe</strong> 所在目录，然后执行以下命令</p>\n</li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">.\\gitlab<span class=\"literal\">-runner</span>.exe register</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p1.ssl.qhimg.com/t015868f4a26eb1c187.png\"></p>\n<blockquote>\n<ol>\n<li><p>Please enter the gitlab-ci coordinator URL</p>\n<p>打开想要设置 <strong>CI</strong> 的 <strong>gitlab</strong> 项目，进入页面 <strong>settings</strong> &gt; <strong>CI/CD</strong> &gt; <strong>Runners</strong> &gt; <strong>Expand</strong>，找到 <strong>Set up a specific Runner manually</strong> ，输入 <strong>Specify the following URL during the Runner setup:</strong> 下的地址</p>\n</li>\n<li><p>Please enter the gitlab-ci token for this runner</p>\n<p>输入 <strong>Use the following registration token during setup:</strong> 下的token字符串</p>\n</li>\n<li><p>Please enter the gitlab-ci description for this runner</p>\n<p>输入一个描述</p>\n</li>\n<li><p>Please enter the gitlab-ci tags for this runner</p>\n<p>输入一个标签，该标签对应该runner</p>\n</li>\n<li><p>Please enter the executor</p>\n<p>这里输入 <strong>shell</strong> 就好</p>\n</li>\n</ol>\n</blockquote>\n<p>此时刷新 <strong>gitlab</strong> 页面会新增一个 <strong>gitlab-runner</strong></p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01365dad71b81d349e.png\"></p>\n<ol start=\"3\">\n<li>执行命令 <strong>install</strong></li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">.\\gitlab<span class=\"literal\">-runner</span>.exe install</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>执行命令 <strong>start</strong></li>\n</ol>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">.\\gitlab<span class=\"literal\">-runner</span>.exe <span class=\"built_in\">start</span></span><br></pre></td></tr></table></figure>\n\n<p>此时刷新 <strong>gitlab</strong> 页面，之前的 <strong>gitlab-runner</strong> 会更新为以下状态，表示 <strong>gitlab-runner</strong> 配置完成，已经可以开始工作。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01ee74b28ae33622a9.png\"></p>\n<h2 id=\"4-修改gitlab-runner服务的登录账号\"><a href=\"#4-修改gitlab-runner服务的登录账号\" class=\"headerlink\" title=\"4. 修改gitlab-runner服务的登录账号\"></a>4. 修改gitlab-runner服务的登录账号</h2><p><img src=\"https://p1.ssl.qhimg.com/t0129f4e0808e3a95fd.png\"></p>\n<p>由于 <strong>gitlab-runner</strong> 服务默认登录账号为 <strong>authority\\system</strong> ，而这个账号在执行微信开发者工具命令行时会出现报错，所以我们需要更改 <strong>gitlab-runner</strong> 服务的登录账号为正确账号并重启该服务。</p>\n<blockquote>\n<p>右击计算机 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务</p>\n<p>找到 <strong>gitlab-runner</strong> 服务</p>\n<p>右击 <strong>gitlab-runner</strong> -&gt; 属性 -&gt; 登录 -&gt; 此账号 -&gt; 输入可以正确使用微信开发者工具命令行的账号和密码 -&gt; 确定 -&gt; 重启动此服务</p>\n</blockquote>\n<p>修改完成后账号会正确被更改</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01a639e59da0c1654b.png\"></p>\n<h2 id=\"5-配置微信开发者工具\"><a href=\"#5-配置微信开发者工具\" class=\"headerlink\" title=\"5. 配置微信开发者工具\"></a>5. 配置微信开发者工具</h2><ol>\n<li>使用你的微信账号登录开发者工具</li>\n<li>设置 -&gt; 安全 -&gt; 服务端口 -&gt; 开启</li>\n</ol>\n<p><img src=\"https://p1.ssl.qhimg.com/t015159defb543bc007.png\"></p>\n<h2 id=\"6-配置-gitlab-ci-yml\"><a href=\"#6-配置-gitlab-ci-yml\" class=\"headerlink\" title=\"6. 配置.gitlab-ci.yml\"></a>6. 配置.gitlab-ci.yml</h2><p>在项目根目录创建 <strong>.gitlab-ci.yml</strong> 文件，并填写以下配置。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">stages:</span> <span class=\"comment\"># 定义阶段用于执行任务</span></span><br><span class=\"line\">  - build</span><br><span class=\"line\">  - deploy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">build_job:</span> <span class=\"comment\"># 定义 build 任务，名称可以随意命名，只是为了方便理解和区分</span></span><br><span class=\"line\">  <span class=\"symbol\">stage:</span> build <span class=\"comment\"># 该任务属于 build 阶段，要严格与stages中定义的命名一致</span></span><br><span class=\"line\">  <span class=\"symbol\">only:</span></span><br><span class=\"line\">    - master</span><br><span class=\"line\">  <span class=\"symbol\">tags:</span> <span class=\"comment\"># tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配</span></span><br><span class=\"line\">    - mp_win7</span><br><span class=\"line\">  <span class=\"symbol\">before_script:</span> <span class=\"comment\"># 执行script之前的钩子</span></span><br><span class=\"line\">    - whoami </span><br><span class=\"line\">  <span class=\"symbol\">script:</span> <span class=\"comment\"># 执行下面脚本，这里可以自定义配置您的构建任务</span></span><br><span class=\"line\">    - echo <span class=\"string\">&quot;build&quot;</span> <span class=\"comment\"># 可以在这里执行您项目的构建编译操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"symbol\">deploy_job:</span> <span class=\"comment\"># 定义 deploy 任务，名称可以随意命名，只是为了方便理解和区分</span></span><br><span class=\"line\">  <span class=\"symbol\">stage:</span> deploy <span class=\"comment\"># 该任务属于 deploy 阶段</span></span><br><span class=\"line\">  <span class=\"symbol\">only:</span></span><br><span class=\"line\">    - master</span><br><span class=\"line\">  <span class=\"symbol\">tags:</span> <span class=\"comment\"># tags 指定运行在哪个 Runner 上，这里需要在我们刚注册的 Runner 运行，和注册时的 mp_win7 匹配</span></span><br><span class=\"line\">    - mp_win7</span><br><span class=\"line\">  <span class=\"symbol\">script:</span> <span class=\"comment\"># 执行下面脚本，这里可以自定义配置您的部署任务</span></span><br><span class=\"line\">    - <span class=\"symbol\">C:</span>\\software\\wechatDevTool\\cli.bat -u <span class=\"number\">0.1</span>.<span class=\"number\">0</span>@<span class=\"string\">&quot;$PWD&quot;</span> --upload-desc 最新的描述 <span class=\"comment\"># 这里使用微信开发者工具提供的命令行工具进行上传体验版操作</span></span><br></pre></td></tr></table></figure>\n\n<p>修改完成后将代码 <strong>push</strong> 到远程仓库，会自动触发CI任务。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t019d51361cb922a675.png\"></p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01f0ac08aa114bca76.png\"></p>\n<p>此时登录微信小程序官网后台，就可以看到刚刚 <strong>push</strong> 代码时由 <strong>gitlab-ci</strong> 自动上传的体验版了。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t011ca19b9ff40db6dc.png\"></p>\n<p>有关 <strong>.gitlab-ci.yml</strong> 的详细配置方法可以参考以下文章。</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21LM3RB\">http://urlqh.cn/mK3tA<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21Oaldz\">http://urlqh.cn/mNjWs<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<h2 id=\"7-持续集成项目方案\"><a href=\"#7-持续集成项目方案\" class=\"headerlink\" title=\"7. 持续集成项目方案\"></a>7. 持续集成项目方案</h2><blockquote>\n<p>以下为本人最近在做的 <strong>360瞭望台</strong> 小程序的持续集成方案，您可以根据自己的需要加以改进，并完成属于你的持续集成方案。</p>\n</blockquote>\n<ol>\n<li><p>由于编写 <strong>.gitlab-ci.yml</strong> 时需要用到微信开发者工具的命令行，所以为了便于团队成员使用，我开发了一个 <strong>node.js</strong> 脚本，并发布为 <strong>npm</strong> 模块，用于在 <strong>.gitlab-ci.yml</strong> 调用 <strong>Windows</strong> 虚拟机中的上传命令。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01a2d503871bbc77ad.png\"></p>\n</li>\n<li><p>约定团队开发流程，开发新需求时创建 <strong>feature/0.5.1</strong>(需求版本号) 分支，当 <strong>push</strong> 代码时会自动触发 <strong>CI</strong> 任务，并在虚拟机修改为 <strong>test</strong> 环境后提交体验版。</p>\n</li>\n<li><p>发完测试报告后可以将小程序提审时，我们需要将 <strong>feature/0.5.1</strong> 分支 <strong>merge</strong> 到 <strong>audit</strong> 分支，此时会自动触发 <strong>CI</strong> 任务，并在虚拟机修改为 <strong>production</strong> 环境后提交体验版。 <strong>audit</strong> 分支需要添加为受保护的分支，不允许直接 <strong>push</strong> 代码，如果审核没通过那么可以以 <strong>audit</strong> 为基础新建 <strong>feature/0.5.2</strong> 分支进行调整后重新 <strong>merge</strong> 到 <strong>audit</strong>。</p>\n</li>\n<li><p>当审核通过后我们需要将 <strong>audit</strong> 分支代码合并到 <strong>master</strong> 分支，<strong>master</strong> 分支应该永远与线上代码保持同步。</p>\n</li>\n</ol>\n<h1 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h1><blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21LaTdU\">http://urlqh.cn/mKi7T<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21KUEND\">http://urlqh.cn/mJPCC<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21JV1Jr\">http://urlqh.cn/mIWRk<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21Kb1ky\">http://urlqh.cn/mJoY2<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3VybHFoLmNuL21MQ0lC\">http://urlqh.cn/mLCIB<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n","categories":["前端"],"tags":["持续集成","微信小程序"]},{"title":"读“在框架设计中寻求平衡”","url":"/2019/12/30/seeking-the-balance-in-framework-design/","content":"<p>今年 JSConf.Asia 会议上，Vue.js 的作者 @尤雨溪 在关于 前端框架设计取舍 上作了分享。 分享主要从两个部分展开介绍： 职责范围（Scope）和 渲染机制（Render Mechanism）。</p>\n<h4 id=\"职责范围\"><a href=\"#职责范围\" class=\"headerlink\" title=\"职责范围\"></a>职责范围</h4><p>小的职责范围具有很好的灵活度，但关于构建抽象上要求开发者有自主学习能力。相反，大的职责范围致力于提供抽象概念，倘若抽象不适用，想改变时，却缺乏灵活度。</p>\n<p>Vue 在职责范围这个问题的处理方式上，采取了渐进式。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01fe27088aa20d3ded.png\"></p>\n<p>通过渐进的方式来选择特性，让更多的人专注于开发，而不是学习一堆在当前开发中可能不需要的概念。对于当前一些问题，开发者仍然能通过文档来获取一些解决方案。</p>\n<p>这种渐进式一来让 Vue 也存在着大职责范围中的统一维护面问题；二来 Vue 生态也无法像小职责范围那样的多样化。</p>\n<a id=\"more\"></a>\n<h4 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h4><p>JSX 具有完整的 JavaScript 表现力，但由于渲染函数的动态特性使其难以优化。模板的约束允许编译器对你的意图作做预判，从而给它更多的空间执行优化；但因受限于模板语法，从而失去了 JavaScript 表达能力。</p>\n<p>单纯取舍不能解决问题，Vue 在渲染机制方面选择了 VDOM 结合模板编译，在模板编译上入手优化，引入了SVELTE，只对动态节点作 VDOM Diff 算法，从而提高了运行速度。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01352166f663a62c22.png\" alt=\"svelte-logo-horizontal.svg\"></p>\n<p>接下来看看 SVELTE 是怎么处理的。</p>\n<p>场景1：只有一个动态节点</p>\n<p><img src=\"https://p3.ssl.qhimg.com/t01712c2274c39bc718.png\" alt=\"image\"></p>\n<p>当模板中只有一个动态节点时，整个节点结构是静态的、不会改变，我们只需直接更新 message 字符串这一个动态节点。</p>\n<p>场景2：存在结构指令</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01514e25d142756025.png\" alt=\"v-if Demo\"></p>\n<p>若存在结构指令 <code>v-if</code>，此时这个节点可能存在或可能不存在。处理办法是进行拆分，以 <code>v-if</code> 为界拆分成两个嵌套块。 </p>\n<ul>\n<li><code>v-if</code> 外部：是一个静态节点结构，只有 <code>v-if</code> 这一个动态节点</li>\n<li><code>v-if</code> 内部：也是一个静态节点结构，只有 <code>&#123;&#123; message &#125;&#125;</code> 一个动态节点</li>\n</ul>\n<p>唯一要处理的就是将每个块内的动态节点数组扁平化。</p>\n<blockquote>\n<p>数组扁平化是指将一个多维数组变为一维数组</p>\n</blockquote>\n<p><img src=\"https://p5.ssl.qhimg.com/t01df369a48ee8b05df.png\" alt=\"v-for Demo\"></p>\n<p>又或者存在的是结构指令 <code>v-for</code>，处理方式也是一样，将代码拆分成嵌套块…</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01a85190317eae945e.png\" alt=\"more v-if, v-for Demo\"></p>\n<p>若模板中存在多个 <code>v-if</code>、<code>v-for</code>，亦是如此。以结构指令为界，将模板拆分成嵌套块。每个块内的节点结构是静态的，动态节点维护在一个单一扁平化数组中。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t015cf5539238c56211.png\" alt=\"Block Tree\"></p>\n<p><img src=\"https://p1.ssl.qhimg.com/t01dc325e2cba4ce2e2.png\" alt=\"Block Tree Demo\"></p>\n<p>假设这个区块树存在上图的节点，那么得出的扁平化数组（结构指令 v-if, v-for 等本身也可以看出一个节点）为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">B5: [node5, node6, node7]</span><br><span class=\"line\">B4: [node1, node2, node3, node4]</span><br><span class=\"line\">B3: [B5]</span><br><span class=\"line\">B2: [B4]</span><br><span class=\"line\">B1: [B2, B3]</span><br></pre></td></tr></table></figure>\n<p>如此一来，对于同一模板的Diff， vue2.x 和 vue3.x 在做法上就存在比较大的差异。vue2.x 会做一个完整的 Diff 操作，而 vue3.x 是比较一个单一扁平化数组中的文本是否发生变化。有实验表明，vue3.0 中使用的新的编译策略的速度比 vue2.x 快了6倍多。虽说是个实验数据，但或多或少，vue3 都是更快。</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t015efdcb0ccb5fb4a3.png\" alt=\"实验数据\"></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>最后，我们回到本次分享中的话题。通过 @尤雨溪 的分享，我们能感受到他在框架设计中是如何寻求平衡的，这对我们今后的框架设计存在着许多借鉴意义。</p>\n<p>如何获取一个最佳平衡点，我们都曾有过努力寻找最佳的方式来解决问题的经历，我想这就是一个寻求最佳平衡点的过程。这个最佳方式不仅能解决现有问题，并且与后期的发展也一致，在我看来，这应该就是最佳平衡点。</p>\n","categories":["阅读"],"tags":["框架设计","Vue"]},{"title":"Gatsby 踩过的那些坑","url":"/2020/04/23/experience-about-gatsby/","content":"<p>开始之前我们先来了解一下 Gatsby.js 是什么。</p>\n<p>官网的介绍是：</p>\n<blockquote>\n<p>Gatsby is a free and open source framework based on React that helps developers build blazing fast websites and apps.</p>\n</blockquote>\n<p>即 Gatsby 是一个基于 React 的开源框架，基于 Gatsby 开发者能够轻易搭建超快站点。</p>\n<p>最近团队的小伙伴基于 Gatsby 开发了几个项目，其优势在于它结合了最新的技术，使开发变得简易快速。但在其便捷的背后不乏踩过的各种坑，今天我们就来分享一些经验，说说那些踩过的坑。</p>\n<h3 id=\"1、CSS-作用域\"><a href=\"#1、CSS-作用域\" class=\"headerlink\" title=\"1、CSS 作用域\"></a>1、CSS 作用域</h3><p>Gatsby 的 CSS 默认是全局样式，在编写不同页面或者组件的时候需要保证 className 不重复，否则会导致样式覆盖或错乱。</p>\n<p>解决办法：</p>\n<a id=\"more\"></a>\n<h4 id=\"CSS-Module-方案\"><a href=\"#CSS-Module-方案\" class=\"headerlink\" title=\"CSS Module 方案\"></a>CSS Module 方案</h4><p>使用 CSS Module 生成只作用于当前模块的 CSS，避免造成样式的全局污染。需要注意的是模块化的 CSS 文件命名需以<code>.module.css</code> 为后缀，内容只需要按照普通 CSS 文件来编写即可：</p>\n<figure class=\"highlight css\"><figcaption><span>moduleA.module.css</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><figcaption><span>moduleA.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> moduleAStyle <span class=\"keyword\">from</span> <span class=\"string\">&quot;../styles/moduleA.module.css&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (&#123; children &#125;) =&gt; (</span><br><span class=\"line\">  &lt;div className=&#123;moduleAStyle.container&#125;&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>其中需要注意 className 的命名，<code>-</code>符号（无论是连续多少个<code>-</code>符号）编译后会自动转为驼峰式命名，以下 moduleB 页面的 h1 标题只会渲染<code>title--default-1</code>定义的样式:</p>\n<figure class=\"highlight css\"><figcaption><span>moduleB.module.css</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.title-default--1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: blueviolet;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.title--default-1</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: brown;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><figcaption><span>moduleB.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> moduleBStyle <span class=\"keyword\">from</span> <span class=\"string\">&quot;../styles/moduleB.module.css&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> classNameToCamel () =&gt; (</span><br><span class=\"line\">  &lt;h1 className=&#123;moduleBStyle.titleDefault1&#125;&gt;ClassNameToCamel&lt;/h1&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> classNameToCamel</span><br></pre></td></tr></table></figure>\n\n<p>当然，你也可以使用 Sass，对应的文件后缀为<code>.module.scss</code>，记得引入对应的插件：</p>\n<figure class=\"highlight js\"><figcaption><span>gatsby-config.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"string\">`gatsby-plugin-sass`</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TIPS\"><a href=\"#TIPS\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h4><ul>\n<li>当一个组件在不同场景下使用需要加载不同样式时，样式模块可以作为变量从父组件传入</li>\n</ul>\n<h4 id=\"CSS-in-JS-方案\"><a href=\"#CSS-in-JS-方案\" class=\"headerlink\" title=\"CSS in JS 方案\"></a>CSS in JS 方案</h4><p>CSS in JS 是在 JS 文件中，使用内联的方式编写样式，同样能达到 CSS 模块化的效果。其原理是在编写了内联样式的元素上，自动添加一个唯一的类名，然后生成一个 CSS 文件，将对应的类名和样式放入其中。Gatsby 官网中推荐了两个库：Emotion 和 Styled Component。</p>\n<p>以 Emotion 为例，首先引入插件：</p>\n<figure class=\"highlight js\"><figcaption><span>gatsby-config.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"string\">`gatsby-plugin-emotion`</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<p>使用：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// styled写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> styled <span class=\"keyword\">from</span> <span class=\"string\">&quot;@emotion/styled&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// styled 返回的是一个组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Title = styled.h1<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  display: inline；;</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Title</span>&gt;</span>这是一个h1标题<span class=\"tag\">&lt;/<span class=\"name\">Title</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// css写法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; css &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@emotion/core&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// css 返回的是样式对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> inline = css`</span><br><span class=\"line\"><span class=\"css\">  <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline</span>；;</span></span><br><span class=\"line\"><span class=\"css\">`</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span> <span class=\"attr\">css</span>=<span class=\"string\">&#123;inline&#125;</span>&gt;</span>这是标题<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用内联方式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</span><br><span class=\"line\">  &lt;h1</span><br><span class=\"line\">    css=&#123;css`</span><br><span class=\"line\"><span class=\"css\">      <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">inline</span>；;</span></span><br><span class=\"line\"><span class=\"css\">    `</span>&#125;</span><br><span class=\"line\">  &gt;</span><br><span class=\"line\">    这是标题</span><br><span class=\"line\">  &lt;/h1&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"styled-jsx-方案\"><a href=\"#styled-jsx-方案\" class=\"headerlink\" title=\"styled-jsx 方案\"></a>styled-jsx 方案</h4><p>styled-jsx 是一个支持 jsx 方式编写的 css-in-js 插件，引入插件后便可直接使用：</p>\n<figure class=\"highlight js\"><figcaption><span>gatsby-config.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: [</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"string\">`styled-jsx`</span>,</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;h1 className=<span class=\"string\">&quot;title&quot;</span>&gt;The title is red&lt;/h1&gt;</span><br><span class=\"line\">    &lt;style jsx&gt;&#123;<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      .title &#123;</span></span><br><span class=\"line\"><span class=\"string\">        color: red;</span></span><br><span class=\"line\"><span class=\"string\">      &#125;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>&#125;&lt;/style&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、移动端-click-事件存在-300ms-延迟\"><a href=\"#2、移动端-click-事件存在-300ms-延迟\" class=\"headerlink\" title=\"2、移动端 click 事件存在 300ms 延迟\"></a>2、移动端 click 事件存在 300ms 延迟</h3><p>这个问题在移动端是普遍存在的（不限于 Gatsby 项目）。最早出现在 ios safari 上，为了判断用户的操作是单击还是双击，浏览器在 click 后等待 300ms 以判断用户是否会再次点击，此后 Android 也实现了这种机制。</p>\n<p>解决办法：</p>\n<h4 id=\"用-touchend-事件代替\"><a href=\"#用-touchend-事件代替\" class=\"headerlink\" title=\"用 touchend 事件代替\"></a>用 touchend 事件代替</h4><p>移动端触摸事件的响应顺序为 touchstart –&gt; touchmove –&gt; touchend –&gt; click，所以可以绑定 touchstart 或者 touchend 事件来代替 click 事件，以 达到加快事件响应的效果，从而解决 300ms 延迟的问题。</p>\n<h4 id=\"引入开源模块\"><a href=\"#引入开源模块\" class=\"headerlink\" title=\"引入开源模块\"></a>引入开源模块</h4><ul>\n<li>fastclick 模块：在检测到 touchend 事件的时候，会通过 DOM 自定义事件模拟一个 click 事件并立即触发执行，并把浏览器在 300ms 之后真正的 click 事件阻止掉。</li>\n<li>zepto 的 touch 模块：模块里定义了一个 tap 事件，通过绑定 tap 事件可以实现 click 立即触发的功能。使用这个模块需要注意“点透”问题。</li>\n</ul>\n<h3 id=\"3、注意代码执行环境\"><a href=\"#3、注意代码执行环境\" class=\"headerlink\" title=\"3、注意代码执行环境\"></a>3、注意代码执行环境</h3><p>在代码中，需要谨慎使用 window、document 等 browser 上才有的对象，因为我们在开发时使用的是浏览器环境，代码构建时是 node 环境。</p>\n<p>解决办法：</p>\n<ul>\n<li>先判断当前的环境是否为 browser 环境再使用：</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> language = <span class=\"built_in\">window</span>.navigator.language;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 hooks 中使用：</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> [language, setLanguage] = useState();</span><br><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  setLanguage(<span class=\"built_in\">window</span>.navigator.language);</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"TIPS-1\"><a href=\"#TIPS-1\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h4><ul>\n<li>当项目中没有使用到 window 等对象时，若编译还是报错<code>window is not defined</code>，可以排查一下项目中使用的依赖项是否使用了该的对象</li>\n</ul>\n<h3 id=\"4、侧边栏组件在-ios-环境下影响-body-样式\"><a href=\"#4、侧边栏组件在-ios-环境下影响-body-样式\" class=\"headerlink\" title=\"4、侧边栏组件在 ios 环境下影响 body 样式\"></a>4、侧边栏组件在 ios 环境下影响 body 样式</h3><p>在移动端使用 gastby + material-ui 时，如果使用侧边栏组件，在 IOS 机器下会出现 body 被莫名推出可视区域的情况。</p>\n<p>解决办法：</p>\n<p>给 gatsby 容器添加<code>overflow: hidden</code>样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#___gatsby</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5、路由问题\"><a href=\"#5、路由问题\" class=\"headerlink\" title=\"5、路由问题\"></a>5、路由问题</h3><p>Gatsby 项目在开发环境中，访问页面 <code>pageA</code>，使用路径<code>/pageA</code> 和<code>/pageA/</code>均可以，但若是线上环境则必须使用<code>/pageA/</code>，同时 Link 的 <code>active</code> 样式也会受到 url 的影响。这个问题是因为 Gatsby 把<code>/src/pages/pageA.js</code>编译成了<code>/public/pageA/index.html</code>。</p>\n<p>解决办法：</p>\n<ul>\n<li>修改 nginx 配置，实现<code>/pageA</code>到<code>/pageA/</code>的重定向，或者<code>try_files $uri $uri/ $uri/index.html =404;</code></li>\n<li>Link 的 active 样式问题，可以设置<code>partiallyActive=&#123;true&#125;</code>采用非完全匹配模式解决</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Link</span><br><span class=\"line\">  activeClassName=&#123;headerStyle.nav__linkActive&#125;</span><br><span class=\"line\">  partiallyActive=&#123;<span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">  to=<span class=\"string\">&quot;/pageA&quot;</span></span><br><span class=\"line\">&gt;</span><br><span class=\"line\">  PAGE A</span><br><span class=\"line\">&lt;/Link&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6、Link-与-a-的区别\"><a href=\"#6、Link-与-a-的区别\" class=\"headerlink\" title=\"6、Link 与 a 的区别\"></a>6、Link 与 a 的区别</h3><p>Gatsby 的 Link 实际上和 react 的 Route 类似，会做优化和预加载，从而加快页面跳转。通过 Link 跳转的话，其实用的是 react 特有的 diff 渲染，这种渲染只会渲染两个页面不同的部分。使用 a 的话，会强制更新整个页面，也就没有了预加载的优势，导致跳转不够快、不够优雅。</p>\n<h4 id=\"TIPS-2\"><a href=\"#TIPS-2\" class=\"headerlink\" title=\"TIPS\"></a>TIPS</h4><ul>\n<li>如果是跳转当前页面并且要更新数据（比如修改页面 url 的 query 时），则必须使用 a 标签</li>\n</ul>\n<h3 id=\"7、静态资源上传-CDN\"><a href=\"#7、静态资源上传-CDN\" class=\"headerlink\" title=\"7、静态资源上传 CDN\"></a>7、静态资源上传 CDN</h3><ul>\n<li>项目在发布打包时需要先清理缓存，否则缓存文件会导致上传 cdn 出错。</li>\n<li>使用 webpack 插件将静态资源上传 CDN 时，Gatsby 会将已上传 CDN 的资源重新定向到本地资源，因此在构建完以后需要重新将资源地址修改为 CDN 资源的地址。</li>\n<li>动态渲染的部分，Gatsby 会以脚本的形式生成所需要的 dom，其中涉及到的静态资源路径会以如下的方式返回：</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> banner <span class=\"keyword\">from</span> <span class=\"string\">&quot;../assets/banner.png&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> skeleton <span class=\"keyword\">from</span> <span class=\"string\">&quot;../assets/skeleton.jpg&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> img0 = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;test-skeleton&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;banner&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> img1 = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;test-skeleton&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;skeleton&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  bool ? img0 : img1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;7CQL&quot;</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, t, n</span>) </span>&#123;</span><br><span class=\"line\">    e.exports = n.p + <span class=\"string\">&quot;static/banner-d9b4af4154903bc4909cc0d613fbb577.png&quot;</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  drUt: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e, t, n</span>) </span>&#123;</span><br><span class=\"line\">    e.exports = n.p + <span class=\"string\">&quot;static/skeleton-ad6c4f26c61c9f0cbf66bf871ba09d4e.jpg&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = n(<span class=\"string\">&quot;q1tI&quot;</span>),</span><br><span class=\"line\">    a = n.n(c),</span><br><span class=\"line\">    s = n(<span class=\"string\">&quot;7CQL&quot;</span>),</span><br><span class=\"line\">    r = n.n(s),</span><br><span class=\"line\">    i = n(<span class=\"string\">&quot;drUt&quot;</span>),</span><br><span class=\"line\">    o = n.n(i),</span><br><span class=\"line\">    b = a.a.createElement(<span class=\"string\">&quot;img&quot;</span>, &#123; <span class=\"attr\">className</span>: <span class=\"string\">&quot;test-banner&quot;</span>, <span class=\"attr\">src</span>: r.a &#125;),</span><br><span class=\"line\">    l = a.a.createElement(<span class=\"string\">&quot;img&quot;</span>, &#123; <span class=\"attr\">className</span>: <span class=\"string\">&quot;test-skeleton&quot;</span>, <span class=\"attr\">src</span>: o.a &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>从中可以看到静态资源路径是由字符串拼接所得，这就导致我们将静态资源上传 cnd 后，无法对编译后的文件中的静态资源路径进行替换。</p>\n<p>解决办法：</p>\n<p>以相对路径的方式直接引用资源，这样编译后的文件中资源路径不会被处理（还是原始字符串形式的相对路径，具体见下方），因此资源上传 cdn 后可以轻松替换路径。需要注意的是这种方式引用的资源不会被打包进最终的 public 文件夹中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译前</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> img0 = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;test-banner&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;assets/banner.png&quot;</span> /&gt;</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> img1 = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">className</span>=<span class=\"string\">&quot;test-skeleton&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;assets/skeleton.jpg&quot;</span> /&gt;</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  bool ? img0 : img1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译后</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = s.a.createElement(<span class=\"string\">&quot;img&quot;</span>, &#123;</span><br><span class=\"line\">    className: <span class=\"string\">&quot;test-banner&quot;</span>,</span><br><span class=\"line\">    src: <span class=\"string\">&quot;assets/banner.png&quot;</span>,</span><br><span class=\"line\">  &#125;),</span><br><span class=\"line\">  r = s.a.createElement(<span class=\"string\">&quot;img&quot;</span>, &#123;</span><br><span class=\"line\">    className: <span class=\"string\">&quot;test-skeleton&quot;</span>,</span><br><span class=\"line\">    src: <span class=\"string\">&quot;assets/skeleton.jpg&quot;</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>更多方案有待探索</p>\n<h3 id=\"8、路由切换时打点\"><a href=\"#8、路由切换时打点\" class=\"headerlink\" title=\"8、路由切换时打点\"></a>8、路由切换时打点</h3><p>若需在路由切换时发送打点，打点逻辑可以在 gatsby-browser.js 中设置：</p>\n<figure class=\"highlight js\"><figcaption><span>gatsby-browser.js</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">exports</span>.onRouteUpdate = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// sendLog</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9、移动端响应布局\"><a href=\"#9、移动端响应布局\" class=\"headerlink\" title=\"9、移动端响应布局\"></a>9、移动端响应布局</h3><p>对于移动端开发，使用 flex + vw 可以满足大部分移动端页面响应式布局的需求，并且相比于媒体查询、rem 来说更加便捷高效。</p>\n<h3 id=\"10、js-主文件导出方式\"><a href=\"#10、js-主文件导出方式\" class=\"headerlink\" title=\"10、js 主文件导出方式\"></a>10、js 主文件导出方式</h3><p>Gatsby 项目的页面都由 pages 目录下的 js 文件构建而成，导出时必须要导出 default 形式，否则无法构建生产版本，同时非构建页面的 js 文件不能放在 pages 目录下。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> IndexPage = <span class=\"function\">() =&gt;</span> (</span><br><span class=\"line\">  &lt;Layout&gt;</span><br><span class=\"line\">    &lt;h1&gt;IndexPage&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/Layout&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> IndexPage;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写在最后的话\"><a href=\"#写在最后的话\" class=\"headerlink\" title=\"写在最后的话\"></a>写在最后的话</h3><p>以上就是团队的经验分享，希望能给大家的踩坑之旅提供一点帮助，也欢迎大家挖坑补坑！</p>\n","categories":["前端"],"tags":["Gatsby"]},{"title":"webpack 那些事儿","url":"/2020/05/25/webpack-learning/","content":"<p>最近看了些webpack相关的视频，对webpack有了进一步的学习，这里做了些总结，可能不全面、片面，欢迎大家指出，一起学习讨论。</p>\n<p>提到webpack先想到的是文件的打包，对代码进行构建，生成的结果用于生产环境。下面以自问自答的形式进行记录：</p>\n<h3 id=\"1-为什么需要对前端代码进行打包呢\"><a href=\"#1-为什么需要对前端代码进行打包呢\" class=\"headerlink\" title=\"1. 为什么需要对前端代码进行打包呢\"></a>1. 为什么需要对前端代码进行打包呢</h3><p>大概有以下几点原因：</p>\n<ul>\n<li><p>开发分工的变化，早期前端开发负责页面的样式实现，简单的交互逻辑。随着单页面应用的盛行，不仅要还原设计稿，较好的过渡效果，动画效果，还需要关注页面的路由变化，页面复杂的交互逻辑，乃至部分接口数据处理逻辑。</p>\n</li>\n<li><p>框架的变化，早期js没有统一的规范，项目中引入js库方便浏览器的兼容。随着技术的发展变革，模块化编程思想的普及，Angular，React，Vue相继登场。</p>\n</li>\n<li><p>语言的变化，逐步规范化，各种预处理器的诞生，eg： sass，typescript</p>\n</li>\n<li><p>环境的变化，早期页面在移动端和浏览器中运行，现在还可以在服务端渲染SSR</p>\n</li>\n<li><p>工具的变化，现在的前端框架有相对完整生态，配套的cli，各种loader，插件，在这些影响下进行模块化开发，项目的文件数量增多，如：采用jade开发模版，sass编写css，typescript实现交互逻辑，可以大大的提高开发效率，那么语言编译就不可或缺了，此时webpack可以解决你的无后顾之忧。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-既然代码的打包势在必行，那webpack都能做哪些事情呢\"><a href=\"#2-既然代码的打包势在必行，那webpack都能做哪些事情呢\" class=\"headerlink\" title=\"2. 既然代码的打包势在必行，那webpack都能做哪些事情呢\"></a>2. 既然代码的打包势在必行，那webpack都能做哪些事情呢</h3><p>webpack的功能还是很强大的，如：代码转换（各种loader）、模块热替换、tree-shaking、代码分离、懒加载、模块合并（创建library）、代码发布，这些都是官网列出的，具体内容可以查看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9ndWlkZXM=\">https://www.webpackjs.com/guides<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ul>\n<h3 id=\"3-webpack功能很多，不足有哪些呢\"><a href=\"#3-webpack功能很多，不足有哪些呢\" class=\"headerlink\" title=\"3. webpack功能很多，不足有哪些呢\"></a>3. webpack功能很多，不足有哪些呢</h3><p>凡事都是有利有弊的，代码打包除了webpack，还有rollup，gulp等，有竟品的存在，就代表webpack有缺点：</p>\n<ul>\n<li>配置复杂；虽然在webpack4.0的版本中推出了零配置的方案，但大多数的使用场景，这个零配置是不满足的，需要开发者根据项目情况引入相应的loader、plugin进行配置。</li>\n<li>体积大；这个体积是指打包的结果，网上可以查到很多解决该问题的方法，提供了相关的组件进行处理。</li>\n<li>编译时间长；开发者都会选择实现新语法进行开发，所以编译是需要对代码进行babel处理，同步处理多文件，时间自然少不了，可以引入happyPack插件实现多进程并行处理，时间会有些优化。</li>\n</ul>\n<h3 id=\"4-webpack构建流程是怎样的呢\"><a href=\"#4-webpack构建流程是怎样的呢\" class=\"headerlink\" title=\"4. webpack构建流程是怎样的呢\"></a>4. webpack构建流程是怎样的呢</h3><p>整个流程是一个串行的过程，流程如下：</p>\n<ul>\n<li>根据webpack.config.json中配置进行参数初始化</li>\n<li>通过配置中的 entry 找出所有的入口文件</li>\n<li>从入口文件出发，调用loader对模块内容进行编译处理，并递归的解析出模块依赖树，一一进行解析</li>\n<li>解析完成得到最终的内容以及它们之间的依赖关系</li>\n<li>根据输出模块配置，将内容组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表</li>\n<li>根据配置中的输出路径和文件名，把文件内容写入到文件系统</li>\n</ul>\n<h3 id=\"5-如何开发自定义loader\"><a href=\"#5-如何开发自定义loader\" class=\"headerlink\" title=\"5. 如何开发自定义loader\"></a>5. 如何开发自定义loader</h3><p>(1) loader定义<br>webpack提倡模块化，loader就是文件的加载器，将所有文件处理成可加载的模块。loader可以链式调用，即一个文件可以被多个loader进行处理，loader的执行与配置中传入数组的顺序相反。在下面的示例中，从 sass-loader 开始执行，然后继续执行 css-loader，最后以 style-loader 为结束。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">        use: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            loader: <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">              modules: <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          &#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;sass-loader&#x27;</span> &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>(2) loader的实现<br>以一个简单需求为例：处理txt文件，字符串以空格分割进行翻转</p>\n<ul>\n<li>创建loader/reverse.js</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(src) &#123;</span><br><span class=\"line\">\t  src = src.split(<span class=\"string\">&#x27; &#x27;</span>).map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (item.charAt(<span class=\"number\">0</span>).toUpperCase() + item.slice(<span class=\"number\">1</span>))).join(<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> src</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在配置中增加</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">rules: [&#123;</span><br><span class=\"line\">\ttest: <span class=\"regexp\">/\\.txt$/</span>,</span><br><span class=\"line\">\tuse: [</span><br><span class=\"line\">\t  <span class=\"string\">&#x27;./loader/reverse.js&#x27;</span>,</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>这样一个简单的loader就实现了，想要看loader的执行顺序，可以在loader中增加调试信息打印查看即可.异步loader需要使用异步方法，可在API官网查看：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvbG9hZGVycy8=\">https://webpack.js.org/api/loaders/<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"6-如何开发插件\"><a href=\"#6-如何开发插件\" class=\"headerlink\" title=\"6. 如何开发插件\"></a>6. 如何开发插件</h3><ul>\n<li>插件定义：<br>Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。<br>webpack 插件由以下组成：<br>一个 JavaScript 命名函数。<br>在插件函数的 prototype 上定义一个 apply 方法。<br>指定一个绑定到 webpack 自身的事件钩子。<br>处理 webpack 内部实例的特定数据。<br>功能完成后调用 webpack 提供的回调。</li>\n<li>插件实现<br>以一个简单需求为例：打包生成html中追加一段js</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddScriptPlugin</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">options</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;AddScriptPlugin constructor:&#x27;</span>, options)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 应用函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">apply</span>(<span class=\"params\">compiler</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定钩子事件</span></span><br><span class=\"line\">    compiler.plugin(<span class=\"string\">&#x27;emit&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> fx = <span class=\"string\">`(function()&#123;console.log(&quot;I&#x27;m fx code, I&#x27;m here, hahaha ~&quot;)&#125;)()`</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> newContent = compilation.assets[<span class=\"string\">&#x27;main.js&#x27;</span>].source() + fx</span><br><span class=\"line\">      compilation.assets[<span class=\"string\">&#x27;main.js&#x27;</span>] = &#123;</span><br><span class=\"line\">        source: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> newContent;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        size: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> newContent.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = AddScriptPlugin</span><br></pre></td></tr></table></figure>\n\n<p>在配置中将其引入，查看打包结果即可。</p>\n<h3 id=\"7-如何编写简单的打包工具，实现代码同步、异步的加载\"><a href=\"#7-如何编写简单的打包工具，实现代码同步、异步的加载\" class=\"headerlink\" title=\"7.如何编写简单的打包工具，实现代码同步、异步的加载\"></a>7.如何编写简单的打包工具，实现代码同步、异步的加载</h3><p>简单流程如下:</p>\n<ul>\n<li>将代码处理成commonjs的形式，浏览器可以加载运行</li>\n<li>解析文件间的依赖关系，采用键值对的形式，以文件路径为key，其值是文件内容</li>\n<li>同步的脚本在加载时通过文件名进行查找加载</li>\n<li>异步的加载通过jsonp的方式，针对使用require.ensure加载的问题，单独打包成jsonp进行加载</li>\n</ul>\n<h3 id=\"8-介绍webpack-dev-server的原理\"><a href=\"#8-介绍webpack-dev-server的原理\" class=\"headerlink\" title=\"8.介绍webpack-dev-server的原理\"></a>8.介绍webpack-dev-server的原理</h3><p>下图是参考文章中截取，详细流程参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGUwY2ZlNDZmYjlhMDcxNjY1ZDNkZjAjaGVhZGluZy0xNA==\">https://juejin.im/post/5de0cfe46fb9a071665d3df0#heading-14<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p><img src=\"http://p2.qhimg.com/t0172b886aa2215d864.jpg\"></p>\n<h3 id=\"9-webpack5-0中Module-Federation的介绍\"><a href=\"#9-webpack5-0中Module-Federation的介绍\" class=\"headerlink\" title=\"9.webpack5.0中Module Federation的介绍\"></a>9.webpack5.0中Module Federation的介绍</h3><p>使用官网的demo进行体验：<a href=\"https://github.com/module-federation/module-federation-examples\" title=\"module-federation-examples/basic-host-remote\">module-federation-examples/basic-host-remote</a><br>项目的结构如下：</p>\n<p><img src=\"http://p406.qhimgs4.com/t0148c597401c530728.png\"></p>\n<p>项目中有app1，app2两个文件夹也就是两个有“牵扯”的项目，分别看下配置文件</p>\n<p><img src=\"http://p406.qhimgs4.com/t011959605aa798c4a0.png\"><br><img src=\"http://p406.qhimgs4.com/t012fa5055eee81e629.png\"></p>\n<p>配置属性：<br>name，必须，唯一 ID，作为输出的模块名，使用的时通过 ${name}/${expose} 的方式使用；<br>library，必须，其中这里的 name 为作为 umd 的 name；<br>remotes，可选，表示作为 Host 时，去消费哪些 Remote；<br>exposes，可选，表示作为 Remote 时，export 哪些属性被消费；<br>shared，可选，优先用 Host 的依赖，如果 Host 没有，再用自己的；</p>\n<p>可以看出app2项目中依赖app1中的button组件，且直接依赖app1中打包生成的文件，使用情况如下：</p>\n<p><img src=\"http://p406.qhimgs4.com/t019af27758b3772b4e.png\"></p>\n<p>代码解析见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvaVMtcHJUMXhaUFY2Y3BIN01IUlJkUQ==\">https://mp.weixin.qq.com/s/iS-prT1xZPV6cpH7MHRRdQ<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>app项目配置插件后，打包index.html时头部会追加remoteEntry.js，它用于加载app2项目中的公用资源。app1项目依赖app2主要分两部分：</p>\n<ul>\n<li>对于shared部分，app1中会自己打包，只是先判断，app2已经加载注册则直接使用，没有的话，就加载打包的内容；</li>\n<li>对于expose部分，如果app2项目挂掉，会影响app1中的使用，因为app1中无button的内容。</li>\n</ul>\n<p>在生产环境的使用中，对于shared内容通过插件使用，可以使用缓存减少加载时间，但对于exposed的内容，可能需要慎重考虑。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>热更新：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGUwY2ZlNDZmYjlhMDcxNjY1ZDNkZjA=\">https://juejin.im/post/5de0cfe46fb9a071665d3df0<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>webpack流程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGUwY2ZlNDZmYjlhMDcxNjY1ZDNkZjA=\">https://juejin.im/post/5dc01199f265da4d12067ebe<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>webpack流程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZGUwY2ZlNDZmYjlhMDcxNjY1ZDNkZjA=\">https://mp.weixin.qq.com/s/LI-SkBoPA94Ply6Qes92PA<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>编写loader：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjcxODM3NA==\">https://segmentfault.com/a/1190000012718374<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>编写plugin：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://www.webpackjs.com/contribute/writing-a-plugin/<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>webpack5.0: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://mp.weixin.qq.com/s/iS-prT1xZPV6cpH7MHRRdQ<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>webpack5.0：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://developer.aliyun.com/article/755252<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>webpack5.0:  <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9jb250cmlidXRlL3dyaXRpbmctYS1wbHVnaW4v\">https://juejin.im/post/5e9eb3de6fb9a03c7d3d1647<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n","categories":["前端"],"tags":["webpack"]},{"title":"git基础原理和使用参考","url":"/2020/07/29/git/","content":"<h1 id=\"Git基础原理和使用参考\"><a href=\"#Git基础原理和使用参考\" class=\"headerlink\" title=\"Git基础原理和使用参考\"></a>Git基础原理和使用参考</h1><h1 id=\"什么是git？\"><a href=\"#什么是git？\" class=\"headerlink\" title=\"什么是git？\"></a>什么是git？</h1><hr>\n<p>git是一款用来执行版本控制的软件，和Subversion、CVS具有相似的特性，例如可以保存修改历史、能恢复某些历史的修改等等，同时，git与传统的版本控制软件在设计思想和实现上差异比较大。<br>早期版本控制软件，例如Subversion，其依赖中心服务器以及客户端到服务器的网络连通性，服务器充当中心结点，所有客户端通过网络协议执行版本控制操作，如果无法连接网络服务，则无法执行相关操作，将这种控制软件方式称为<strong>集中式版本控制</strong>，其优点在于部署简便，不需要考虑多个客户端如何协作。这种软件架构在Linux内核这种强调协作开发模式时逐渐暴露缺陷，绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上。<br>与集中式对应的则是<strong>分布式版本控制</strong>，git就是分布式版本控制软件的一种，每个客户端都拥有完整的仓库代码，除非需要推送到远程，大部分操作是发生在本地文件系统，摆脱对于网络连通性的强依赖，甚至中心服务器故障时，可以使用某个客户端充当新的中心节点。                                        </p>\n<blockquote>\n<p>Linux内核开源社区从2002年开始使用BitKeeper，同样是一款分布式版本控制软件，在2005年BitKeeper的商业公司同Linux内核开源社区的合作关系结束，于是Linux内核开源社区不得不另起炉灶。最初他们对git有以下期待：</p>\n<ul>\n<li>速度    </li>\n<li>简单的设计</li>\n<li>支持非线性开发模式即允许大量并行开发分支</li>\n<li>完全分布式</li>\n<li>有能力高效管理类似 Linux 内核一样的超大规模项目                                    </li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>除了分布式之外，git对待版本更新的方法和Subversion有些不同，Subversion会把版本看成是一组文件随时间的累积结果，基于差异去控制版本，如下所示<br><img src=\"https://p0.ssl.qhimg.com/t017c9c532826f24b2d.png\" alt=\"svn.png\"><br>git把每次提交保存为文件系统的快照，出于效率考虑如果没有修改则不保存，只是保留指向之前版本的链接，整体上看git更像是个<strong>内容寻址文件**</strong>系统**，如下所示<br><img src=\"https://p1.ssl.qhimg.com/t01a492b7a573aec6bc.png\" alt=\"git.png\"></p>\n<h1 id=\"基础概念和原理\"><a href=\"#基础概念和原理\" class=\"headerlink\" title=\"基础概念和原理\"></a>基础概念和原理</h1><h2 id=\"对象状态\"><a href=\"#对象状态\" class=\"headerlink\" title=\"对象状态\"></a>对象状态</h2><p>在git中操作对象叫做文件对象，包括三种状态，分别是已提交(commited)、已修改(modified)、已暂存(staged)</p>\n<ul>\n<li>已修改表示已经修改了文件，但是还没有保存到本地文件数据库</li>\n<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</li>\n<li>已提交表示数据已经安全地保存在本地数据库中</li>\n</ul>\n<p>以上三种状态对象的集合则是<strong>git目录、工作区和暂存区</strong>，其中已提交对应git目录，已修改对应工作区，已暂存对应暂存区                                        </p>\n<blockquote>\n<p>工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<br>暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。<br>Git目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据</p>\n</blockquote>\n<h2 id=\"对象和对象数据库\"><a href=\"#对象和对象数据库\" class=\"headerlink\" title=\"对象和对象数据库\"></a>对象和对象数据库</h2><p>所有git相关的数据都是存储在.git目录下，其中git对象存储在.git/objects即对象数据库。<br>可以通过如下代码，实现插入一个对象到对象数据库中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;add demo object&#x27;</span> &gt; demo.txt</span><br><span class=\"line\">git hash-object -w demo.txt</span><br></pre></td></tr></table></figure>\n<p>这时系统会返回长度为40的字符哈希校验和，注意不同的运行环境所得到的哈希校验和可能不同</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">effc69903ad516acb116f3405664ae909efaaefb</span><br></pre></td></tr></table></figure>\n<p>这是将待存储的数据和必要的头信息组合并使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TSEEtMS8xNjk5NjkyP2Zyb210aXRsZT1TSEExJmZyb21pZD04ODEyNjcx\">SHA-1算法<i class=\"fa fa-external-link-alt\"></i></span>生成，<br>此时执行以下指令，就可以看到对象数据库新增1个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">find .git/objects -<span class=\"built_in\">type</span> f</span><br></pre></td></tr></table></figure>\n<p>系统返回如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.git/objects/ef/fc69903ad516acb116f3405664ae909efaaefb</span><br></pre></td></tr></table></figure>\n<p>如果我想要查看这个对象的值，则可以使用刚刚返回的哈希校验和获取</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git cat-file -p effc69903ad516acb116f3405664ae909efaaefb</span><br></pre></td></tr></table></figure>\n<p>系统返回如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">add demo object</span><br></pre></td></tr></table></figure>\n<p>如果我们修改demo.txt文件内容并再次添加到对象数据库中，这时查看对象数据库则会发现又新增1个对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;add another object&#x27;</span> &gt; demo.txt</span><br><span class=\"line\">git hash-object -w demo.txt</span><br></pre></td></tr></table></figure>\n<p>系统返回如下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">38b902fd6011c714c82785d9cd12421fe21f48e0</span><br></pre></td></tr></table></figure>\n<p>查看对象数据库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">find .git/objects -<span class=\"built_in\">type</span> f</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.git/objects/38/b902fd6011c714c82785d9cd12421fe21f48e0</span><br><span class=\"line\">.git/objects/ef/fc69903ad516acb116f3405664ae909efaaefb</span><br></pre></td></tr></table></figure>\n<p>依然可以使用git cat-file -p获取到任何一个对象，而这就是git核心特性之一，将数据保存到本地对象数据库中，其中key是哈希校验和<br>只要有哈希校验和和完整对象数据库，我们可以获取任何一个版本的数据对象</p>\n<h2 id=\"树对象\"><a href=\"#树对象\" class=\"headerlink\" title=\"树对象\"></a>树对象</h2><p>数据都存储在对象数据库中，但是存取的路径和文件名还没有保存，git以一种类似于 UNIX 文件系统的方式存储，所有内容均以树对象和数据对象的形式存储。<br>其中树对象对应了 UNIX 中的目录项，数据对象则大致上对应了 inodes 或文件内容<br> 一个树对象包含了一条或多条树对象记录(tree entry)，每条记录含有一个指向数据对象或者子树对象的 SHA-1 指针以及相应的模式、类型、文件名信息。<br>首先创造1个新对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p path</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;add path object&#x27;</span> &gt; path/demo.txt</span><br><span class=\"line\">git hash-object -w path/demo.txt</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">a2d4add8726a7ca24590a8a3199fda8ac5f93e48</span><br></pre></td></tr></table></figure>\n<p>Git 通常根据某一时刻暂存区(即 index 区域，下同)所表示的状态创建并记录一个对应的树对象， 如此重复便可依次记录(某个时间段内)一系列的树对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git update-index --add --cacheinfo 100644 a2d4add8726a7ca24590a8a3199fda8ac5f93e48 path/demo.txt</span><br><span class=\"line\">git update-index --add --cacheinfo 100644 38b902fd6011c714c82785d9cd12421fe21f48e0 demo.txt</span><br></pre></td></tr></table></figure>\n<p>通过git update-index将文件提交到暂存区，再通过git write-tree将暂存区对象写入树对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git write-tree</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">d31a14e8590e683e30a754e5f846bb61cb99ae5d</span><br></pre></td></tr></table></figure>\n<p>这时对象数据库中就会新增一个对象类型，通过git cat-file可以看到对象类型是树对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git cat-file -p d31a14e8590e683e30a754e5f846bb61cb99ae5d</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">100644 blob 38b902fd6011c714c82785d9cd12421fe21f48e0\tdemo.txt</span><br><span class=\"line\">040000 tree 654277737a15bb7db0276f585f711d4175cbcfd8\tpath</span><br></pre></td></tr></table></figure>\n<p>由于树对象是和UNIX文件系统对应，树对象可以引用另一个树对象，继续使用git cat-file可以查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git cat-file -p 654277737a15bb7db0276f585f711d4175cbcfd8</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">100644 blob a2d4add8726a7ca24590a8a3199fda8ac5f93e48\tdemo.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"提交对象\"><a href=\"#提交对象\" class=\"headerlink\" title=\"提交对象\"></a>提交对象</h2><p>提交对象是引用树对象并记录谁在什么时候增加树对象，相当于树对象的操作记录，通过</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;new tree&#x27;</span> | git commit-tree d31a14e8590e683e30a754e5f846bb61cb99ae5d</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">25b8654df0b5571aa8e76d6a2d83fe124d365948</span><br></pre></td></tr></table></figure>\n<p>这时通过git log就可以看到提交的记录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> 25b8654df0b5571aa8e76d6a2d83fe124d365948</span><br></pre></td></tr></table></figure>\n<p>git所做的工作实质就是将被改写的文件保存为数据对象， 更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。<br>这三种主要的 Git 对象——数据对象、树对象、提交对象——最终均以单独文件的形式保存在 .git/objects 目录下</p>\n<h2 id=\"引用对象\"><a href=\"#引用对象\" class=\"headerlink\" title=\"引用对象\"></a>引用对象</h2><p>实际上引用对象就是提交对象的别名，我们可以用git update-ref创建引用对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git update-ref refs/heads/demo 25b8654df0b5571aa8e76d6a2d83fe124d365948</span><br></pre></td></tr></table></figure>\n<p>这时我们就可以使用refs/heads/demo来引用提交对象，这样的表示方式更加方便记忆，而这基本就是git分支的本质，存储在.git/refs/heads下的对提交对象的别名<br>在这些引用对象中有一个HEAD对象，通常指向为目前所在的分支，当用git commit创建新的提交对象后，并用HEAD文件中那个引用所指向的SHA-1值设置其父提交字段                                        </p>\n<h1 id=\"常见使用场景\"><a href=\"#常见使用场景\" class=\"headerlink\" title=\"常见使用场景\"></a>常见使用场景</h1><h2 id=\"初始化git目录\"><a href=\"#初始化git目录\" class=\"headerlink\" title=\"初始化git目录\"></a>初始化git目录</h2><p>对于任意的目录，都可以通过git init来初始化</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取远程git目录到本地\"><a href=\"#获取远程git目录到本地\" class=\"headerlink\" title=\"获取远程git目录到本地\"></a>获取远程git目录到本地</h2><p>使用git clone指令来获取远程的git数据</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> git@github.com:git/git.git</span><br></pre></td></tr></table></figure>\n<h2 id=\"回顾变更\"><a href=\"#回顾变更\" class=\"headerlink\" title=\"回顾变更\"></a>回顾变更</h2><p>可以使用git log来查看提交对象，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=raw</span><br></pre></td></tr></table></figure>\n<h2 id=\"检查工作区和暂存区状态\"><a href=\"#检查工作区和暂存区状态\" class=\"headerlink\" title=\"检查工作区和暂存区状态\"></a>检查工作区和暂存区状态</h2><p>使用git status查看工作区和暂存区的对象状态，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git status</span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">Changes not staged <span class=\"keyword\">for</span> commit:</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class=\"line\">  (use <span class=\"string\">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class=\"keyword\">in</span> working directory)</span><br><span class=\"line\">\tmodified:   hello.txt</span><br><span class=\"line\"></span><br><span class=\"line\">no changes added to commit (use <span class=\"string\">&quot;git add&quot;</span> and/or <span class=\"string\">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>这时表明hello.txt文件还没有添加到暂存区，仍在工作区</p>\n<h2 id=\"如何提交变更\"><a href=\"#如何提交变更\" class=\"headerlink\" title=\"如何提交变更\"></a>如何提交变更</h2><ol>\n<li>在工作区修改文件</li>\n<li>通过git add将想要的变更文件选择性地添加到暂存区</li>\n<li>通过git commit将暂存区的文件生成快照存储到git目录的提交对象，并更新HEAD引用</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git add hello.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;hello,world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[master 0a7d684] hello,world</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\"> create mode 100644 hello.txt</span><br></pre></td></tr></table></figure>\n\n<p>有时刚刚commit后发现少提交一些文件，如果再次commit一次会把提交日志搞得奇怪，而且还得再写一次提交的message，这时可以默认使用上一条提交message</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit --amend</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"临时保留修改\"><a href=\"#临时保留修改\" class=\"headerlink\" title=\"临时保留修改\"></a>临时保留修改</h2><p>有时在工作区的修改还没有达到提交状态，这时如果有一个临时的想法想去实现，可以使用git stash来临时保存工作区状态</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git stash</span><br></pre></td></tr></table></figure>\n<p>当临时想法实现完毕后，可以使用git stash apply来恢复刚刚的工作区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git stash apply</span><br></pre></td></tr></table></figure>\n<p>恢复完毕后，建议清理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git stash clean</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销工作区修改\"><a href=\"#撤销工作区修改\" class=\"headerlink\" title=\"撤销工作区修改\"></a>撤销工作区修改</h2><p>这时使用git checkout来恢复工作区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git checkout -- hello.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销提交到暂存区\"><a href=\"#撤销提交到暂存区\" class=\"headerlink\" title=\"撤销提交到暂存区\"></a>撤销提交到暂存区</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git add hello.txt</span><br></pre></td></tr></table></figure>\n<p>这时就需要使用git reset来恢复暂存区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset HEAD hello.txt</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"撤销提交\"><a href=\"#撤销提交\" class=\"headerlink\" title=\"撤销提交\"></a>撤销提交</h2><p>这时需要使用git reset –hard来实现，这个指令可以提供回滚到上一个版本，也可以通过提供SHA-1回滚到任意提交对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset --hard HEAD^1</span><br></pre></td></tr></table></figure>\n<p>如果又想反悔，也只需要找到那个提交对象，就可以找回某次的提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset --hard 0a7d684</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h2><p>在git中新建分支非常容易，O(1)复杂度，实际上就是对当前的HEAD对象创建1个引用对象，使用git switch -c可以创建分支后自动切换到新分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git switch -c feature</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git switch feature</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"查看分支\"><a href=\"#查看分支\" class=\"headerlink\" title=\"查看分支\"></a>查看分支</h2><p>使用如下指令可以检查git的分支以及当前所在的分支，当前分支前面会标一个*号</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><p>删除分支依旧使用git branch，只是需要新增参数-d和分支名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch -d feature</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h2><p>在大型项目开发中，合并分支往往非常频繁，这是因为需要经常集成其他人的贡献和代码，最常用的合并是通过git merge实现，如下就是实现master分支和feature分支合并</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git switch master</span><br><span class=\"line\">git merge feature</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，这里的合并是指本地对象合并，并不是远程的对象<br>然而，合并并不总是那么愉快，有时会伴随冲突，如果当前分支的父提交不是要合并的分支，则无法使用快进合并，如下为快速合并场景</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git switch master</span><br><span class=\"line\">git switch -c <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git add hello.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;merge branch&quot;</span></span><br><span class=\"line\">git switch master</span><br><span class=\"line\">git merge <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Updating 0a7d684..44d6a4c</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\"> hello.txt | 2 +-</span><br><span class=\"line\"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>\n<p>可以看到由于test分支的父提交和当前master的提交一致，符合快速合并原则，可以使用使用test分支的最新提交并设置父提交为master的最新提交<br>如果test分支创建后，master分支又产生新的提交对象，就不符合快速合并原则，需要人工处理</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git switch master</span><br><span class=\"line\">git switch -c <span class=\"built_in\">test</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,new world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git add hello.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;merge branch&quot;</span></span><br><span class=\"line\">git switch master</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;hello,master world&#x27;</span> &gt; hello.txt</span><br><span class=\"line\">git add hello.txt</span><br><span class=\"line\">git commit -m <span class=\"string\">&quot;master branch&quot;</span></span><br><span class=\"line\">git merge <span class=\"built_in\">test</span></span><br></pre></td></tr></table></figure>\n<p>系统返回</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Auto-merging hello.txt</span><br><span class=\"line\">CONFLICT (content): Merge conflict <span class=\"keyword\">in</span> hello.txt</span><br><span class=\"line\">Automatic merge failed; fix conflicts and <span class=\"keyword\">then</span> commit the result</span><br></pre></td></tr></table></figure>\n<p>冲突的问题会将两个版本进行标记</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class=\"string\">HEAD</span></span><br><span class=\"line\"><span class=\"string\">hello,master world</span></span><br><span class=\"line\"><span class=\"string\">=======</span></span><br><span class=\"line\"><span class=\"string\">hello, new world</span></span><br><span class=\"line\"><span class=\"string\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; test</span></span><br></pre></td></tr></table></figure>\n<p>这时就需要人工处理好文件后，重新添加到暂存区并提交</p>\n<h2 id=\"与远程协作\"><a href=\"#与远程协作\" class=\"headerlink\" title=\"与远程协作\"></a>与远程协作</h2><p>将本地的分支关联到远程分支，实际上就是创建一类特殊的远程引用对象，这个引用对象是只读的<br>通过git push将本地的对象提交到远程，如下就是把本地的master分支推送到远程，前提是需要对目标仓库有写权限</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote add origin git@github.com:git/git.git</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<p>值得注意的是，如果使用git commit –amend则在push时，需要使用-f参数，如下所示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git push -f origin master</span><br></pre></td></tr></table></figure>\n<p>使用git pull来更新远程分支到本地</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n","categories":["前端"],"tags":["git"]},{"title":"你想 pick 哪款嵌入式 Markdown 编辑器?","url":"/2020/09/01/pick-embeddable-markdown-editor/","content":"<p>首先先声明下，我们今天要讲的并非客户端软件，而是“嵌入式”的 Markdown。</p>\n<p>什么是嵌入式？嵌入式是计算机工程中的一个专业术语，即嵌入式系统。</p>\n<blockquote>\n<p>嵌入式系统用于控制、监视或者辅助操作机器和设备的装置，是一种专用的计算机系统。</p>\n</blockquote>\n<p>本文中提到的嵌入式，其实更偏向于这种解释：一个可插拔的组件。</p>\n<p>插上它，某个功能就会实现。拔掉，又不会影响系统运行。</p>\n<p>Markdown是一种轻量级标记语言，易读易写，对图片、图标、数学式都有支持。可用于十几种编程语言，目前许多平台和框架都支持Markdown，主要应用在各个笔记和博客平台。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p><strong>Markdown的时间轴</strong></p>\n<p>它诞生于2004年</p>\n<p>2014年9月，被更名为 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tb25tYXJrLm9yZy8=\">CommonMark<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>2012年，实施标准化</p>\n<p>2017年，Github发布了基于CommonMark的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0v\">Github Flavored Markdown（GFM）<i class=\"fa fa-external-link-alt\"></i></span>的正式规范。</p>\n<p>2018年，发布 CommonMark 规范和测试包</p>\n<p>…</p>\n</blockquote>\n<p>此时，你可能会cue到富文本编辑器，它拥有着类 Word 软件般的用户体验————所见即所得，但其致命的缺点是容易造成 XSS 漏洞。</p>\n<p>跑偏了，今天的主角不是它『富文本』，而是它『Markdown』👈</p>\n<p>接下来推荐几款小编接触到的可嵌入的Markdown编辑器。</p>\n<h2 id=\"tui-editor\"><a href=\"#tui-editor\" class=\"headerlink\" title=\"tui.editor\"></a>tui.editor</h2><p>第一款是由韩国 nhn 官方维护 <code>tui.editor</code>。</p>\n<p><a href=\"https://github.com/nhn/tui.editor\">TOAST UI Editor</a> 是一款的基于 GFM(GitHub Flavored Markdown)的编辑器，拥有两个模式 Markdown 和 WYSIWYG（所见即所得），可在写作过程中任意切换。 用户体验也是相当的舒适，对于偏好富文本编辑器的用户来说，可谓是顺滑切换。</p>\n<p>如果你读过 tui.editor 的文档，是否也和我一样觉得真香呢。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>提供了3种框架组件<ul>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/jquery-editor\">@toast-ui/jquery-editor</a></li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/react-editor\">@toast-ui/react-editor</a></li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/apps/vue-editor\">@toast-ui/vue-editor</a></li>\n</ul>\n</li>\n<li>提供了强大的 Markdown 语法的扩展插件<ul>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/chart\">chart</a> 图表</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/code-syntax-highlight\">code-syntax-highlight</a> 代码块区域高亮</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/color-syntax\">color-syntax</a> 文本颜色选择器</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/table-merged-cell\">table-merged-cell</a> 表格合并单元格</li>\n<li><a href=\"https://github.com/nhn/tui.editor/tree/master/plugins/uml\">uml</a> UML（ 统一建模语言）图</li>\n</ul>\n</li>\n<li>提供了丰富的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9uaG4uZ2l0aHViLmlvL3R1aS5lZGl0b3IvbGF0ZXN0Lw==\">API<i class=\"fa fa-external-link-alt\"></i></span>，方便使用者开发自己的扩展</li>\n<li>在浏览器支持方面也是很喜人，支持IE 10+</li>\n<li>支持Viewer模式（只读模式），用于编辑器内容的最终呈现（多用于详情页中）</li>\n<li>支持<a href=\"https://github.com/nhn/tui.editor/blob/master/apps/editor/docs/i18n.md#supported-languages\">国际化</a></li>\n</ul>\n<p>介绍到这，你是否也心动了。喜欢它，就Pick它吧~</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9uaG4uZ2l0aHViLmlvL3R1aS5lZGl0b3IvbGF0ZXN0L3R1dG9yaWFsLWV4YW1wbGUwMS1lZGl0b3ItYmFzaWM=\">在线demo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"SimpleMDE\"><a href=\"#SimpleMDE\" class=\"headerlink\" title=\"SimpleMDE\"></a>SimpleMDE</h2><p><a href=\"https://github.com/sparksuite/simplemde-markdown-editor\">SimpleMDE</a> 是一个可嵌入的JavaScript Markdown编辑器，除了基础的字体加粗、倾斜，插入图片、链接等功能外，还支持自动保存和拼写检查。</p>\n<p>小编研究了下，这个自动保存是基于 localStorage 存储，如果你用到这个功能了，切记尽量不存储base64格式的图片，不然会造成内存溢出。你懂得『毕竟localstorage只支持5M大小』。</p>\n<p>在预防XSS攻击方面，作者并未对此做处理。从github的代码提交时间来看，目前已不再维护，深表遗憾。如果你有想法，可以fork 它，自己维护，小编表示很赞同呢。</p>\n<p>这款编辑器虽未像 tui.editor一样，提供了 “所见即所得”模式，但它有贴心地提供了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaW1wbGVtZGUuY29tL21hcmtkb3duLWd1aWRl\">Markdown使用指南<i class=\"fa fa-external-link-alt\"></i></span>，不管你的项目是基于 Vue 还是 React，你都可以Pick它，还是很nice的~</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zaW1wbGVtZGUuY29tLw==\">在线demo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<hr>\n<p>以上两款，不管在哪个框架中都能使用。接下来介绍三款分别基jQuery、Vue和React的Markdown Editor组件</p>\n<hr>\n<h2 id=\"Editor-md\"><a href=\"#Editor-md\" class=\"headerlink\" title=\"Editor.md\"></a>Editor.md</h2><p><a href=\"https://github.com/pandao/editor.md\">Editor.md</a> 是一款国产可嵌入的开源 Markdown 在线编辑器组件。基于 CodeMirror、jQuery 和 Marked 构建。同时支持通用 Markdown / CommonMark 和 GFM (GitHub Flavored Markdown) 风格的语法，特性相当丰富。在这5款编辑器中，目前 Star 数也是仅次于 tui.editor。</p>\n<p>它的特性也是很丰富，总有一个满足你的要求😍。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>支持实时预览、图片（跨域）上传、预格式文本/代码/表格插入、代码折叠、搜索替换、只读模式、自定义样式主题和多语言语法高亮等功能；</li>\n<li>支持 ToC 目录（Table of Contents）、Emoji 表情、Task lists、@链接等 Markdown 扩展语法；</li>\n<li>支持 TeX 科学公式（基于 KaTeX）、流程图 Flowchart 和 时序图 Sequence Diagram;</li>\n<li>支持识别和解析 HTML 标签，并且支持自定义过滤标签解析，具有可靠的安全性和几乎无限的扩展性；</li>\n<li>支持 AMD / CMD 模块化加载（支持 Require.js &amp; Sea.js），并且支持自定义扩展插件；</li>\n<li>兼容主流的浏览器（IE8+）和 Zepto.js，且支持 iPad 等平板设备；</li>\n<li>支持自定义主题样式；</li>\n</ul>\n<p>虽说这款编辑器已经对基础的XSS攻击做了处理，但还是存在安全隐患，由于它目前处于维护态，可能维护者已经在修BUG的路上了。如果你有解决办法，可以给它提 <a href=\"https://github.com/pandao/editor.md/compare\">PR</a> 👈。</p>\n<p>如果你对我所说的安全隐患有兴趣，可以试运行以下代码。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://pandao.github.io/editor.md/images/logos/editormd-logo-180x180.png&quot;</span> <span class=\"attr\">onload</span>=<span class=\"string\">&quot;javascript:alert(1)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2VkaXRvci5tZC5pcGFuZGFvLmNvbS8=\">在线demo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"uiw-react-md-editor\"><a href=\"#uiw-react-md-editor\" class=\"headerlink\" title=\"@uiw/react-md-editor\"></a>@uiw/react-md-editor</h2><p><a href=\"https://github.com/uiwjs/react-md-editor\">@uiw/react-md-editor</a> 是一个由 React 和 TypeScript 实现的带有预览的 Markdown 编辑器。目前由 uiw 团队维护。</p>\n<blockquote>\n<p>uiw 是基于 React 16+ 的 UI 组件库。</p>\n</blockquote>\n<p>👉它的特性：</p>\n<ul>\n<li>三种模式任意切换：编辑、预览、编辑 + 实时预览</li>\n<li>支持Viewer模式（只读模式），用于编辑器内容的最终呈现。最常见于文章详情页的展示</li>\n<li>支持 KaTeX 科学公式预览</li>\n<li>包体积很小，才 439 kB</li>\n</ul>\n<p>因为它是一个 React 组件，所以用法也很简单。直接引入，加上配置就哦了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> MDEditor <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@uiw/react-md-editor&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(<span class=\"string\">&quot;**Hello world!!!**&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div className=<span class=\"string\">&quot;container&quot;</span>&gt;</span><br><span class=\"line\">      &lt;MDEditor</span><br><span class=\"line\">        value=&#123;value&#125;</span><br><span class=\"line\">        onChange=&#123;setValue&#125;</span><br><span class=\"line\">      /&gt;</span><br><span class=\"line\">      &lt;MDEditor.Markdown source=&#123;value&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly91aXdqcy5naXRodWIuaW8vcmVhY3QtbWQtZWRpdG9yLw==\">在线demo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"mavon-editor\"><a href=\"#mavon-editor\" class=\"headerlink\" title=\"mavon-editor\"></a>mavon-editor</h2><p><a href=\"https://github.com/hinesboy/mavonEditor\">mavonEditor</a>是一个基于 Vue 的 Markdown 编辑器。目前它是由个人维护，实现了部分国际化，支持8种语言。看过之前几款后，再来看它，有种眼前一亮的感觉，因为它的特性很新颖。可以在vue中使用，也可以在 nuxt.js 中使用。</p>\n<p>👉它的特性：</p>\n<ul>\n<li>支持上下角标</li>\n<li>支持文字高亮（标记笔）</li>\n<li>支持下划线</li>\n<li>支持布局：居左、居中、居右</li>\n<li>支持 KATEX公式 预览</li>\n<li>支持标题导航</li>\n<li>支持国际化</li>\n<li>支持快捷键设置</li>\n<li>支持撤回、恢复、清空等等</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzEwNi4xNS4yMzIuMjIv\">在线demo<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"一览\"><a href=\"#一览\" class=\"headerlink\" title=\"一览\"></a>一览</h2><table>\n<thead>\n<tr>\n<th>editor</th>\n<th>关注数</th>\n<th>更新情况</th>\n<th>存在xss风险级别</th>\n<th>框架支持情况</th>\n<th>npm包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>tui.editor</td>\n<td>11k+</td>\n<td>一个月前</td>\n<td>低</td>\n<td>支持jQuery, Vue, React</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHRvYXN0LXVpL2VkaXRvcg==\">@toast-ui/editor<i class=\"fa fa-external-link-alt\"></i></span></td>\n</tr>\n<tr>\n<td>SimpleMDE</td>\n<td>8k</td>\n<td>4年前</td>\n<td>高</td>\n<td>支持jQuery, Vue, React</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2ltcGxlbWRl\">simplemde<i class=\"fa fa-external-link-alt\"></i></span></td>\n</tr>\n<tr>\n<td>editor.md</td>\n<td>10k+</td>\n<td>16个月前</td>\n<td>较低</td>\n<td>支持jQuery</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZWRpdG9yLm1k\">editor.md<i class=\"fa fa-external-link-alt\"></i></span></td>\n</tr>\n<tr>\n<td>@uiw/react-md-editor</td>\n<td>134</td>\n<td>几天前</td>\n<td>较低</td>\n<td>支持React</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvQHVpdy9yZWFjdC1tZC1lZGl0b3I=\">@uiw/react-md-editor<i class=\"fa fa-external-link-alt\"></i></span></td>\n</tr>\n<tr>\n<td>mavonEditor</td>\n<td>4.2k</td>\n<td>4个月前</td>\n<td>较低</td>\n<td>支持Vue</td>\n<td><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWF2b24tZWRpdG9y\">mavon-editor<i class=\"fa fa-external-link-alt\"></i></span></td>\n</tr>\n</tbody></table>\n<p>以上是这几个嵌入式 Markdown 编辑器的一览。除了小编介绍的这几款，肯定还有很多其他优秀的 Markdown 编辑器，如果你知道也可推荐给我。</p>\n<p>推荐了这么多款，总有一款适合你，快点来Pick吧！！！</p>\n","categories":["前端"],"tags":["Markdown","编辑器"]},{"title":"博客之旅：从 Jekyll 到 Hexo","url":"/2020/11/26/build-hexo-blog/","content":"<p><img src=\"https://user-images.githubusercontent.com/16272760/99784261-872d3200-2b56-11eb-807c-869042d1f6e8.png\"></p>\n<p>初出茅庐之时，看到他人的博客，总会产生一丝新鲜感，好奇之心让你不知不觉跟随着他人的脚步，在写作平台开始展露拳脚。</p>\n<p>发布了两三篇文章后，又发现有些人并非在写作平台写作，而是在拥有自己域名的博客平台发布。就像小时候看到邻居小孩吃糖，不知甜不甜就想着自己也能吃一块。然后就开始折腾了，购买域名空间，独立搭建博客。</p>\n<p>从写文章到搭建博客这思路是对的，但不乏带有点跟风之意。博客，技术圈的个人名片。特别是在招聘面试时，部分面试官会特别关注面试者是否有个人博客，一来从博客上能看出面试者的表达能力和涉猎，二来能看到个人的代码水平和编码习惯。</p>\n<p>此外，博客的书写对个人也是一种技能锻炼。资料的整理，特别是技术问题的整理，有助于自己下一次遇到类似的问题时能否更好的回忆细节和复用相关代码。</p>\n<p>但如何能又快又好的搭建，这是讲究方法的。</p>\n<a id=\"more\"></a>\n\n<p>笔者在开发博客前，简单做了调研，了解到当下最受欢迎的搭建模式就是借助<a href=\"https://github.com/\">GitHub Page</a>和静态博客框架。接下来向大家介绍整个博客的搭建流程。</p>\n<h1 id=\"Github-Pages-入门\"><a href=\"#Github-Pages-入门\" class=\"headerlink\" title=\"Github Pages 入门\"></a>Github Pages 入门</h1><ol>\n<li>首先，<a href=\"https://github.com/join\">注册Github帐号</a>。<br><img src=\"https://p1.ssl.qhimg.com/t01b00009360875756d.png\" alt=\"注册Github帐号\"></li>\n<li>然后，将代码托管在 Github 上。<br>新建一个 repository。如果你希望你的站点能通过 &lt;你的 GitHub 用户名&gt;.github.io 域名访问，你的 repository 应该直接命名为 &lt;你的 GitHub 用户名&gt;.github.io。例如，<code>qwebfe.github.io</code>。</li>\n<li>最后配置 Github Pages，具体细节详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ndWlkZXMuZ2l0aHViLmNvbS9mZWF0dXJlcy9wYWdlcy8=\">Getting Started with GitHub Pages<i class=\"fa fa-external-link-alt\"></i></span>。</li>\n</ol>\n<h1 id=\"静态博客框架\"><a href=\"#静态博客框架\" class=\"headerlink\" title=\"静态博客框架\"></a>静态博客框架</h1><p>根据笔者调研，网上讨论最多的博客框架当属 Jekyll 和 Hexo。有人说，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9qZWt5bGxyYi5jb20v\">Jekyll<i class=\"fa fa-external-link-alt\"></i></span> 就是为了写博客打造的。Github Pages 中提供的 Jekyll 主题似乎也验证了这点。早期组内的博客也是基于 Jekyll 搭建的，其原因我想大概是 GitHub 自带 Jekyll 引擎，无需部署静态页面，只放项目源码即可。后因开发环境依赖问题不便维护，便弃 Jekyll 从 Hexo。据说 Hexo 的出现是因为 Jekyll 比较慢，大概是早期 Hexo 还不够成熟，还不支持自动化部署，也给使用者带来了不便，但那个时候已经过去了。接下来向大家具体介绍 Jekyll 和 Hexo。 </p>\n<h2 id=\"Jekyll\"><a href=\"#Jekyll\" class=\"headerlink\" title=\"Jekyll\"></a>Jekyll</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gem install bundler jekyll</span><br><span class=\"line\"></span><br><span class=\"line\">jekyll new my-awesome-site</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">cd</span> my-awesome-site</span><br><span class=\"line\"></span><br><span class=\"line\">bundle <span class=\"built_in\">exec</span> jekyll serve</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># =&gt; Now browse to http://localhost:4000</span></span><br></pre></td></tr></table></figure>\n\n<p>通过以上几个命令可以看出，Jekyll 是基于 Ruby 实现的，安装 Jekyll 需要搭建 Ruby 环境，但在 Windows 搭建 Ruby 环境并不被推荐。若你是 Windows 用户，那可能一开始就跌倒在安装 Jekyll 的起跑线上。</p>\n<p>我们组的早期博客基于 Jekyll，运行了小一年时间，但用户体验不是很好。受环境搭建影响，多数成员无法启动本地服务器，都是盲写文章，推送上线后，发现问题再修复。有一次把文章日期提前了一天，上线后新文章一直未被构建。无法本地预览，一定程度上影响排查效率。后面求助了同事，也没找到原因，但在第二天早上被告知文章构建成功了。笔者一时蒙蔽，后查阅了各手资源，才得知以下这个答案：</p>\n<blockquote>\n<p>Jekyll 是不会构建未来日期的文章的！</p>\n</blockquote>\n<p>在主题方面，有想法的你可自行选择<a href=\"https://github.com/topics/jekyll-theme\">Jekyll主题</a>。按照安装提示，或基于gem，或只取远程主题，或直接直接拷贝至项目中，然后配置 <code>_config.yml</code> 文件即可。</p>\n<figure class=\"highlight yml\"><figcaption><span>_config.yml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">minimal-mistakes-jekyll</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>厌倦了 Jekyll 的那段爱恨情仇，最终投向了 Hexo 的怀抱。</p>\n<hr>\n<h2 id=\"Hexo\"><a href=\"#Hexo\" class=\"headerlink\" title=\"Hexo\"></a>Hexo</h2><blockquote>\n<p>A fast, simple &amp; powerful blog framework<br>快速、简洁且高效的博客框架</p>\n</blockquote>\n<p>Hexo 是基于 NodeJs 实现，在 Windows 上安装 NodeJs 开发环境可谓是相当简单。何其美哉！乐哉！</p>\n<p>Hexo 默认的主题是 <code>landscape</code>，接触过博客园的童鞋可能觉得该主题有它的味道。萝卜青菜各有所爱，你可自行选择<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=\">主题<i class=\"fa fa-external-link-alt\"></i></span>。关于 <code>Hexo</code> 的主题，笔者想说是我喜欢的调调😉，本组博客应用的主题是<span class=\"exturl\" data-url=\"aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy8=\">NexT<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h3><p>啥也不说了，搬砖吧。</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo init &lt;folder&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">cd &lt;folder&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">npm server</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>M：咦? 这一套指令好像在哪见过👀。<br>H：🙊 vue ?<br>M：嗷呜…</p>\n</blockquote>\n<p>项目初始化完成后，指定文件夹的目录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── _config.yml # 网站的 配置 信息</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── scaffolds</span><br><span class=\"line\">├── source</span><br><span class=\"line\">|   ├── _drafts</span><br><span class=\"line\">|   └── _posts</span><br><span class=\"line\">└── themes</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>scaffolds: 模版文件夹, 当你新建文章时，Hexo 会根据 scaffold 来建立文件</li>\n<li>source: 资源文件夹，存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li>\n<li>themes: 主题文件夹，把你想要的主题拷贝至当前目录即可。</li>\n<li>_config.yml: 网站的配置信息，Hexo 这个点很友好，它给相关配置都做了注释和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s\">文档说明<i class=\"fa fa-external-link-alt\"></i></span>。<ul>\n<li>theme: 你选用的主题，默认为 <code>landscape</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"写作\"><a href=\"#写作\" class=\"headerlink\" title=\"写作\"></a>写作</h3><p>项目创建完成后，我们就可以开始写作了。关于写作，Hexo cli 也提供了相关指令，可快速创建一篇新文章或者新的页面。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>layout，Hexo 有三种默认布局：post、page 和 draft。基于不同类型创建的文件会存储在各自对应的路径中，你可以编辑 <code>scaffolds/*</code> 下的模板文件，保证新页面的规范性。</li>\n<li>title，Hexo 默认以标题做为文件名称，但你可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让你更方便的通过日期来管理文章。</li>\n</ul>\n<figure class=\"highlight yml\"><figcaption><span>_config.yml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">new_post_name:</span> <span class=\"string\">:year-:month-:day-:title.md</span></span><br></pre></td></tr></table></figure>\n\n<p>执行指令时只需输入文件名，创建成功会自动带上当天日期，文件内容也会按照模板格式显示。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"built_in\">test</span> <span class=\"comment\"># ==&gt; source/_posts/2020-12-01-test.md</span></span><br></pre></td></tr></table></figure>\n\n\n<p>若你想了解更多使用方法，可前往<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv\">hexo官网<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>Hexo 官方介绍了三种部署方式。由于我们代码托管在了 Github 上，那笔者就部署到 <code>GitHub Pages</code> 展开介绍。</p>\n<p>1、将你本地的 Hexo 站点文件夹推送到 repository（<code>&lt;你的 GitHub 用户名&gt;.github.io</code>） 中。默认情况下 public 目录将不会被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 public 一行，如果没有请加上。<br>2、将 <a href=\"https://github.com/marketplace/travis-ci\">Travis CI</a> 添加到你的 GitHub 账户中。<br><img src=\"https://p4.ssl.qhimg.com/t012a4eb716b67ab0e7.png\" alt=\"选择一个账号\"><br><img src=\"https://p3.ssl.qhimg.com/t0150046ab66f6286a6.png\" alt=\"授予此应用访问权限\"><br><img src=\"https://p0.ssl.qhimg.com/t0177f583632427bf95.png\" alt=\"授予项目访问权限\"></p>\n<p>3、前往 GitHub 的 <a href=\"https://github.com/settings/installations\">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。若你在第2步忘记了设置 <code>Travis CI</code> 的仓库权限，也可在此重新配置。</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t01a8332cda870c3db1.png\" alt=\"配置 Travis CI 权限\"></p>\n<p><img src=\"https://p2.ssl.qhimg.com/t01867de50a8cd84260.png\" alt=\"设置 Travis CI 的仓库权限\"></p>\n<p>4、保存设置后你应该会被重定向到 Travis CI 的页面。如果没有，请 <span class=\"exturl\" data-url=\"aHR0cHM6Ly90cmF2aXMtY2kuY29tLw==\">手动前往<i class=\"fa fa-external-link-alt\"></i></span>。<br>5、在浏览器新建一个标签页，前往 GitHub <a href=\"https://github.com/settings/tokens\">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。<br><img src=\"https://p5.ssl.qhimg.com/t012b03686dfd70e308.png\" alt=\"新建 Personal Access Token\"><br>6、回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code> ，<strong>Value</strong> 为刚才你在 GitHub 生成的 <strong>Token</strong>。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。<br><img src=\"https://p4.ssl.qhimg.com/t01d2f70045349a4ccf.png\"><br>7、在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件：</p>\n<figure class=\"highlight yml\"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sudo:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">node_js</span></span><br><span class=\"line\"><span class=\"attr\">node_js:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"number\">10</span> <span class=\"comment\"># use nodejs v10 LTS</span></span><br><span class=\"line\"><span class=\"attr\">cache:</span> <span class=\"string\">npm</span></span><br><span class=\"line\"><span class=\"attr\">branches:</span></span><br><span class=\"line\">  <span class=\"attr\">only:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">master</span> <span class=\"comment\"># build master branch only</span></span><br><span class=\"line\"><span class=\"attr\">script:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span> <span class=\"comment\"># generate static files</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">provider:</span> <span class=\"string\">pages</span></span><br><span class=\"line\">  <span class=\"attr\">skip-cleanup:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">github-token:</span> <span class=\"string\">$GH_TOKEN</span></span><br><span class=\"line\">  <span class=\"attr\">keep-history:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">on:</span></span><br><span class=\"line\">    <span class=\"attr\">branch:</span> <span class=\"string\">master</span></span><br><span class=\"line\">  <span class=\"attr\">local-dir:</span> <span class=\"string\">public</span></span><br></pre></td></tr></table></figure>\n\n<p>8、将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下.<br>9、在 GitHub 中前往你的 repository 的设置页面，修改 <code>GitHub Pages</code> 的部署分支为 <code>gh-pages</code>。<br><img src=\"https://p1.ssl.qhimg.com/t01c28f4fde1a753294.png\" alt=\"设置页面gh-pages\"><br>10、前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看你的站点是否可以访问。这可能需要一些时间。</p>\n<p>或许你觉得这种基于 Travis CI 的部署方式配置繁琐，但你要知道一旦配置走通，后期部署都走自动化，对于团队博客而言能在一定程度上减轻心智负担。你要是真不想配置，推荐使用官方的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudA==\">一键部署<i class=\"fa fa-external-link-alt\"></i></span>，但这种部署方式每次都要人工执行操作。</p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>还是那句话，萝卜青菜个有所爱。从 Jekyll 到 Hexo，这趟旅行虽说不易，但旅途中的风景也是令人难忘。若你还有更好用的博客框架，可留言推荐给笔者和大家。</p>\n","categories":["教程"],"tags":["Hexo","Github","Jekyll","Travis","博客"]},{"title":"手把手教你搭建一个基于 sourcegraph 代码搜索网站","url":"/2021/03/26/about-sourcegraph/","content":"<p>现有企业的代码一般都是托管在 GitLab 上，其理由，无非是免费、可以部署到自己的服务器上，所有信息都掌握在自己手中，非常适合团队内部协作。而 Github 虽也致力于免费托管开源代码，但如需建立私有仓库就需付费，看到付费两字，很多人都望而却步。但在代码搜索方面，Github 做的比 GitLab 精彩。</p>\n<p>如何弥补 GitLab 在智能搜索方面的缺憾呢，笔者想推荐个工具给你 ——— <span class=\"exturl\" data-url=\"aHR0cHM6Ly9hYm91dC5zb3VyY2VncmFwaC5jb20vZ2V0LXN0YXJ0ZWQ=\">Sourcegraph<i class=\"fa fa-external-link-alt\"></i></span>，一款开源的代码搜索浏览工具。检索速度也是毫秒级的。</p>\n<p>如何搭建呢？你听我娓娓道来。🥰</p>\n<p><img src=\"https://p5.ssl.qhimg.com/t0139aea3fa431d9ea6.png\"></p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>💡小贴士：<br>本文是在以下环境中进行实践的。</p>\n<p>操作系统：Linux<br>环境要求：安装了 docker</p>\n</blockquote>\n<h2 id=\"🛠️安装-Sourcegraph\"><a href=\"#🛠️安装-Sourcegraph\" class=\"headerlink\" title=\"🛠️安装 Sourcegraph\"></a>🛠️安装 Sourcegraph</h2><p>目前官方就提供了一个使用 Docker 安装的示例，命令也是相当简短：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --publish 7080:7080 --publish 127.0.0.1:3370:3370 --rm --volume ~/.sourcegraph/config:/etc/sourcegraph --volume ~/.sourcegraph/data:/var/opt/sourcegraph sourcegraph/server:3.26.0</span><br></pre></td></tr></table></figure>\n\n<p>笔者将其进行了优化处理，为容器指定了个名称，更换了两个本机端口，以后台模式启动容器，方便后续说明。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\"> --name sgdev2 \\</span><br><span class=\"line\"> --publish 27080:7080 \\</span><br><span class=\"line\"> --publish 127.0.0.1:23370:3370 \\</span><br><span class=\"line\"> --rm \\</span><br><span class=\"line\"> --volume ~/.sourcegraph/config:/etc/sourcegraph \\</span><br><span class=\"line\"> --volume ~/.sourcegraph/data:/var/opt/sourcegraph \\</span><br><span class=\"line\"> sourcegraph/server:3.26.0</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Usage：<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code> 创建一个新的容器并运行一个命令</p>\n</blockquote>\n<ul>\n<li><code>-d/--detach</code>：后台模式启动一个容器</li>\n<li><code>--name</code>：为容器指定一个名称</li>\n<li><code>--rm</code>：退出时自动移除容器</li>\n<li><code>-p/--publish</code>：指定端口映射，格式为：主机(宿主)端口:容器端口。关于端口映射的具体说明，可参考文章<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk0NjA5L2FydGljbGUvZGV0YWlscy81MTczMDY0MA==\">Docker端口映射<i class=\"fa fa-external-link-alt\"></i></span>。官方示例中就是将本机的两个端口7080和3370映射到容器的端口7080和3370上，若是本机端口7080和3370被占用，也可更改为未占用的端口号，例如27080和23370，就如笔者优化后的示例。</li>\n<li><code>-v/--volume</code>：指定容器卷。上面的命令指定了两个卷，即在本机创建数据卷 <code>~/.sourcegraph/config</code>（配置） 和 <code>~/.sourcegraph/data</code>（数据）（题外话，可以改成任何你想放置的位置，例如：<code>~/.sourcegraph2/config</code>、<code>~/.sourcegraph2/data</code>），分别挂载到容器的 <code>/etc/sourcegraph</code> 和 <code>/var/opt/sourcegraph</code> 路径上。这样容器运行过程中，在容器中生产的数据会被保存到容器所在的节点上（<code>~/.sourcegraph/config</code> 和 <code>~/.sourcegraph/data</code>）。</li>\n</ul>\n<p>若你不设置 <code>-d</code>，执行成功后，会出现以下提示，让你访问 <code>http://127.0.0.1:7080</code>，但上述命令我们已经将 7080 映射到 27080 端口。故正确的访问地址是 <code>http://127.0.0.1:27080</code>。</p>\n<p><img src=\"https://p3.ssl.qhimg.com/t0168e932b15a6f1c98.png\"></p>\n<p>若你是在服务器上执行 docker 命令，那我们还需进行 nginx 配置才能访问。</p>\n<figure class=\"highlight plain\"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80;</span><br><span class=\"line\">  server_name sgdev2.example.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  location &#x2F; &#123;</span><br><span class=\"line\">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:27080;</span><br><span class=\"line\">    proxy_set_header X-Real-IP  $remote_addr;</span><br><span class=\"line\">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">    proxy_set_header Host $host;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改完配置，我们需重启下nginx <code>/usr/sbin/nginx -s reload</code>（没权限就加sudo）。接着在客户端上配置下 hosts，假设服务器IP为 <code>10.11.xx.xx</code>，配置完后直接访问 <code>http://sgdev2.example.com</code>。出现如下界面就成功了，第一次访问页面注册的是管理员，注册完登录就可以进行站点设置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">10.11.xx.xx sgdev2.example.com</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://p5.ssl.qhimg.com/t011017c72c20b43768.png\"></p>\n<blockquote>\n<p>💡docker 小贴士：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sgdev2 为容器名</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker ps <span class=\"comment\"># 查看运行中的容器</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker restart sgdev2 <span class=\"comment\"># 重启容器 sgdev2</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker start sgdev2 <span class=\"comment\"># 启动容器 sgdev2</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker stop sgdev2 <span class=\"comment\"># 停止运行中的容器 sgdev2</span></span><br><span class=\"line\"></span><br><span class=\"line\">docker <span class=\"built_in\">kill</span> -s KILL sgdev2 <span class=\"comment\"># 杀掉一个运行中的容器</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"⚙️配置-Sourcegraph-网站\"><a href=\"#⚙️配置-Sourcegraph-网站\" class=\"headerlink\" title=\"⚙️配置 Sourcegraph 网站\"></a>⚙️配置 Sourcegraph 网站</h2><h3 id=\"仓库设置\"><a href=\"#仓库设置\" class=\"headerlink\" title=\"仓库设置\"></a>仓库设置</h3><p>入口：<code>Site admin</code> &gt; <code>Repositories</code> &gt; <code>Manage code hosts</code></p>\n<p>sourcegraph 提供了多种仓库供你选择。笔者选择了自己接触最多的 Github 和 GitLab 分别进行配置、解说。</p>\n<p><img src=\"https://p4.ssl.qhimg.com/t01e985c2331e5932ea.png\"></p>\n<h4 id=\"配置-Github-仓库\"><a href=\"#配置-Github-仓库\" class=\"headerlink\" title=\"配置 Github 仓库\"></a>配置 Github 仓库</h4><p>点击 Github，进入仓库配置页面：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://github.com&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;token&quot;</span>: <span class=\"string\">&quot;&lt;access token&gt;&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;orgs&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;&lt;你的github用户名&gt;&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;access token&gt;</code> 生成步骤详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vZ2l0aHViL2F1dGhlbnRpY2F0aW5nLXRvLWdpdGh1Yi9jcmVhdGluZy1hLXBlcnNvbmFsLWFjY2Vzcy10b2tlbg==\">Create a GitHub access token<i class=\"fa fa-external-link-alt\"></i></span>，授权范围（scope）设置为 <strong>repo</strong>。</p>\n<p>设置成功后，点击 <code>Repositories</code> &gt; <code>Repository status</code> 就能查看到所有授权的仓库。开发者可根据需要重复上述操作即可。</p>\n<h4 id=\"配置-Gitlab-仓库\"><a href=\"#配置-Gitlab-仓库\" class=\"headerlink\" title=\"配置 Gitlab 仓库\"></a>配置 Gitlab 仓库</h4><p>点击 GitLab，进入仓库配置页面：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://&lt;你的gitlab域名&gt;&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;token&quot;</span>: <span class=\"string\">&quot;&lt;access token&gt;&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;projectQuery&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;projects?membership=true&amp;archived=no&quot;</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;access token&gt;</code> 生成步骤详见 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vZWUvdXNlci9wcm9maWxlL3BlcnNvbmFsX2FjY2Vzc190b2tlbnMuaHRtbCNjcmVhdGluZy1hLXBlcnNvbmFsLWFjY2Vzcy10b2tlbg==\">Create a GitLab access token<i class=\"fa fa-external-link-alt\"></i></span>，授权范围（scope）设置为 <strong>api</strong></p>\n<blockquote>\n<p>若你配置了 GitLab 授权登录（下文即将介绍），希望<strong>查找的仓库权限能跟授权账号走</strong>。可以在仓库配置中加入 <code>Enforce permissions (OAuth)</code></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;authorization&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;identityProvider&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;oauth&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"用户授权\"><a href=\"#用户授权\" class=\"headerlink\" title=\"用户授权\"></a>用户授权</h3><p>入口：<code>Site admin</code> &gt; <code>Configuration</code> &gt; <code>Site configuration</code></p>\n<p>进入配置页，我们可以看到默认认证方式是用户注册登录，管理员可以直接在后台添加用户，此外网站还支持 GitLab / Github 授权登录。接下来笔者着重对这两种授权方式展开说明。</p>\n<h4 id=\"GitLab-授权登录\"><a href=\"#GitLab-授权登录\" class=\"headerlink\" title=\"GitLab 授权登录\"></a>GitLab 授权登录</h4><p>首先，创建一个 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vZWUvaW50ZWdyYXRpb24vb2F1dGhfcHJvdmlkZXIuaHRtbA==\">GitLab 授权应用程序<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<blockquote>\n<p>💡小贴士：</p>\n<ol>\n<li>在 GitLab 右上角选择你的头像</li>\n<li>选择 <strong>Settings</strong> （或是 <strong>Edit profile</strong>）</li>\n<li>在左侧边栏选择 <strong>Applications</strong></li>\n<li>输入 <strong>Name</strong>，<strong>Redirect URI</strong>，<strong>Scopes</strong>(授权范围设置为<code>api</code>、<code>read_user</code>)。<strong>Redirect URI</strong>是用户授权回调的地址，形如：<code>http://sgdev2.example.com/.auth/gitlab/callback</code></li>\n<li>点击保存，就能看到 <code>Application ID</code> 和 <code>Secret</code>。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://p5.ssl.qhimg.com/t012dfa80c5385b4daa.png\"></p>\n<p>然后，回到 sourcegraph 网站站点进行配置。</p>\n<blockquote>\n<p>💡小贴士：</p>\n<ol>\n<li>在你的 sourcegraph 站点的右上角选择你的头像</li>\n<li>选择 <strong>Site admin</strong></li>\n<li>在左侧边栏选择 <strong>Site configuration</strong></li>\n<li>点击 <strong>Add GitLab sign-in</strong>，会自动添加如下授权代码。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight json\"><figcaption><span>Site configuration</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;auth.providers&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// See https://docs.sourcegraph.com/admin/auth#gitlab for instructions</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;gitlab&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;displayName&quot;</span>: <span class=\"string\">&quot;GitLab&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;&lt;GitLab URL&gt;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;clientID&quot;</span>: <span class=\"string\">&quot;&lt;client ID&gt;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;clientSecret&quot;</span>: <span class=\"string\">&quot;&lt;client secret&gt;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>type</code> 和 <code>displayName</code> 保持默认。<code>&lt;GitLab URL&gt;</code> 改为你的 GitLab 地址，<code>&lt;client ID&gt;</code> 改为之前获得的 <code>Application ID</code>，<code>&lt;client secret&gt;</code> 改为 <code>Secret</code>，保存即可。</p>\n<p>此时你退出，再登录就会出现，GitLab 授权按钮。</p>\n<p><img src=\"https://p0.ssl.qhimg.com/t01fe2400ac3070f849.png\"></p>\n<h4 id=\"Github-授权登录\"><a href=\"#Github-授权登录\" class=\"headerlink\" title=\"Github 授权登录\"></a>Github 授权登录</h4><p>与 GitLab 授权登录类似，先创建一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuZ2l0aHViLmNvbS9hcHBzL2J1aWxkaW5nLW9hdXRoLWFwcHMvY3JlYXRpbmctYW4tb2F1dGgtYXBwLw==\">Github 授权应用程序<i class=\"fa fa-external-link-alt\"></i></span></p>\n<blockquote>\n<p>💡小贴士：</p>\n<ol>\n<li>在 Github 右上角选择你的头像</li>\n<li>选择 <strong>Settings</strong></li>\n<li>在左侧边栏选择 <strong>Developer settings</strong></li>\n<li>在左侧边栏选择 <code>OAuth Apps</code>，点击 <code>Register a new application</code></li>\n<li>输入 <strong>Application Name</strong>, <strong>Homepage URL</strong>，<strong>Authorization callback URL</strong>是用户授权回调的地址，形如：<code>http://sgdev2.example.com/.auth/github/callback</code></li>\n<li>点击 <code>Register application</code>，就能看到 <code>Client ID</code> 和 <code>Client secret</code>。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://p2.ssl.qhimg.com/t016bab50fbb17519d9.png\"></p>\n<p><img src=\"https://p4.ssl.qhimg.com/t0101a836846565dc69.png\"></p>\n<p>同样，回到我们的 sourcegraph 配置页。点击 <strong>Add Github sign-in</strong>，会自动添加如下授权代码：</p>\n<figure class=\"highlight json\"><figcaption><span>Site configuration</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;auth.providers&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">// See https://docs.sourcegraph.com/admin/auth#github for instructions</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;github&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;displayName&quot;</span>: <span class=\"string\">&quot;GitHub&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;url&quot;</span>: <span class=\"string\">&quot;https://github.com/&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;allowSignup&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;clientID&quot;</span>: <span class=\"string\">&quot;&lt;client ID&gt;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;clientSecret&quot;</span>: <span class=\"string\">&quot;&lt;client secret&gt;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>type</code> 和 <code>displayName</code> 保持默认。<code>url</code> 改为你的 Github 地址，<code>&lt;client ID&gt;</code> 改为之前获得的 <code>Client ID</code>，<code>&lt;client secret&gt;</code> 改为 <code>Client secret</code>，保存即可。</p>\n<h2 id=\"小结❤️\"><a href=\"#小结❤️\" class=\"headerlink\" title=\"小结❤️\"></a>小结❤️</h2><p>按理安装完 Sourcegraph，进行仓库配置后，站点就能正常投入使用了。关于用户授权，是笔者经历一番探索的总结，为有此需求的人在阅读官方文档中即将陷入迷茫提供的一个提示。</p>\n<p>温馨提示：</p>\n<ul>\n<li><p>若是你通过 GitLab 授权管理用户，需确保网站管理员为代码仓库的管理员，这样能保证用户的搜索池全面。</p>\n</li>\n<li><p>免费版的 Sourcegraph 只能注册10个用户哦！</p>\n</li>\n<li><p>升级应该在 Sourcegraph 的连续次要版本之间进行。例如，如果您正在运行Sourcegraph 3.1，并且想要升级到3.3，则应该先升级到3.2，再升级到3.3。</p>\n</li>\n</ul>\n","categories":["教程"],"tags":["Github","Sourcegraph","GitLab","授权登录","智能搜索"]},{"title":"解密Vue3.0的新特性","url":"/2020/05/13/explain-new-characters-vue3/","content":"<p><img src=\"https://p1.ssl.qhimg.com/t01803ad9bd07851fc7.png\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>尤大大早在2019年10月5日就开放了vue3的源码，时隔半年，于今年的4月17日发布了vue3.0的Beta版本，4月21日B站开直播，对vue3.0做分享总结，这一连串的操作，也算是兢兢业业，大写的优秀了。这篇文章重点来解密一下他在视频里所提及的一些新特性，包括性能方面的大幅度提升，Tree-shaking抖动，Fragments，Teleport，Suspense，自定义渲染API等，其中最重磅的莫过于Composition API了，虽然有那么点像React Hooks，但是气质上还是有很多不同的，下面会具体介绍。先附上Beta版源码地址：<a href=\"https://github.com/vuejs/vue-next#status-beta\">https://github.com/vuejs/vue-next#status-beta</a>，供大家仔细研读。</p>\n<h1 id=\"Performance\"><a href=\"#Performance\" class=\"headerlink\" title=\"Performance\"></a>Performance</h1><h2 id=\"Virtual-Dom\"><a href=\"#Virtual-Dom\" class=\"headerlink\" title=\"Virtual Dom\"></a>Virtual Dom</h2><p>相信使用过前端框架React的人，对虚拟Dom应该很熟悉了。它的核心思想就是抽象原生Dom，封装对应操作的API。其中的Diff算法算是核心难点。vue3.0这次优化主要就是在Diff算法上下了很多功夫。它是怎么来实现的呢？主要通过<code>patchflag</code>来标记不同类型的数据，来实现动态数据的动态更新，区分静态数据，这样只会在最开始的时候加载一次，后续编译过程中均直接略过，从而达到提升渲染速度的目的。效果是，upadate的性能提升了1.3~2倍，开启ssr的情况下可以提升2~3倍，所以在性能方面的提升还是很可观的。我们来看下一个代码示例：</p>\n<a id=\"more\"></a>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;span&gt;&#123;&#123; vue3 &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"vue2的编译结果\"><a href=\"#vue2的编译结果\" class=\"headerlink\" title=\"vue2的编译结果\"></a>vue2的编译结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function anonymous() &#123;</span><br><span class=\"line\">  with(this) &#123;</span><br><span class=\"line\">    return _c(&#39;div&#39;, &#123;</span><br><span class=\"line\">      attrs: &#123;</span><br><span class=\"line\">        &quot;id&quot;: &quot;app&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, [_ssrNode(&quot;&lt;span&gt;&quot; + _ssrEscape(_s(vue3)) +</span><br><span class=\"line\">      &quot;&lt;&#x2F;span&gt; &lt;span&gt;vue&lt;&#x2F;span&gt;&quot;)])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次vue3值变化的时候，所有的节点都会重新创建，显然性能是额外损耗的。</p>\n<h4 id=\"vue3的编译结果\"><a href=\"#vue3的编译结果\" class=\"headerlink\" title=\"vue3的编译结果\"></a>vue3的编译结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const _hoisted_1 &#x3D; &#123; id: &quot;app&quot; &#125;</span><br><span class=\"line\">const _hoisted_2 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;vue&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\"></span><br><span class=\"line\">export function render(_ctx, _cache) &#123;</span><br><span class=\"line\">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class=\"line\">    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.vue3), 1 &#x2F;* TEXT *&#x2F;),</span><br><span class=\"line\">    _hoisted_2</span><br><span class=\"line\">  ]))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们注意到，vue3的动态节点，被标记了1，这个数字就是<code>patchflag</code>值，这里表示text类型。它的作用，主要是在之后的动态更新过程中，判断当前Dom节点是否有此标记，如果有，就update该节点，如果没有，就忽略不更新。如此，就能把性能损耗降到最低。尤其是在拥有大量静态节点的Dom结构里，性能提升会更显著。</p>\n<h3 id=\"patchflag标记\"><a href=\"#patchflag标记\" class=\"headerlink\" title=\"patchflag标记\"></a>patchflag标记</h3><p>patchflag的值有很多，我们常用到的有text、props，组合类型和事件监听等。下面是代码里列举的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 这里注释仅供参考。</span><br><span class=\"line\">export const enum PatchFlags &#123;</span><br><span class=\"line\">  TEXT &#x3D; 1,&#x2F;&#x2F; 表示具有动态textContent的元素</span><br><span class=\"line\">  CLASS &#x3D; 1 &lt;&lt; 1,  &#x2F;&#x2F; 表示有动态Class的元素</span><br><span class=\"line\">  STYLE &#x3D; 1 &lt;&lt; 2,  &#x2F;&#x2F; 表示动态样式（静态如style&#x3D;&quot;color: red&quot;，也会提升至动态）</span><br><span class=\"line\">  PROPS &#x3D; 1 &lt;&lt; 3,  &#x2F;&#x2F; 表示具有非类&#x2F;样式动态道具的元素。</span><br><span class=\"line\">  FULL_PROPS &#x3D; 1 &lt;&lt; 4,  &#x2F;&#x2F; 表示带有动态键的道具的元素，与上面三种相斥</span><br><span class=\"line\">  HYDRATE_EVENTS &#x3D; 1 &lt;&lt; 5,  &#x2F;&#x2F; 表示带有事件监听器的元素</span><br><span class=\"line\">  STABLE_FRAGMENT &#x3D; 1 &lt;&lt; 6,   &#x2F;&#x2F; 表示其子顺序不变的片段（没懂）。 </span><br><span class=\"line\">  KEYED_FRAGMENT &#x3D; 1 &lt;&lt; 7, &#x2F;&#x2F; 表示带有键控或部分键控子元素的片段。</span><br><span class=\"line\">  UNKEYED_FRAGMENT &#x3D; 1 &lt;&lt; 8, &#x2F;&#x2F; 表示带有无key绑定的片段</span><br><span class=\"line\">  NEED_PATCH &#x3D; 1 &lt;&lt; 9,   &#x2F;&#x2F; 表示只需要非属性补丁的元素，例如ref或hooks</span><br><span class=\"line\">  DYNAMIC_SLOTS &#x3D; 1 &lt;&lt; 10,  &#x2F;&#x2F; 表示具有动态插槽的元素</span><br><span class=\"line\">  &#x2F;&#x2F; 特殊 FLAGS -------------------------------------------------------------</span><br><span class=\"line\">  HOISTED &#x3D; -1,  &#x2F;&#x2F; 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag &#x3D;&#x3D;&#x3D; FLAG.</span><br><span class=\"line\">  BAIL &#x3D; -2 &#x2F;&#x2F; 一个特殊的标志，指代差异算法（没懂）</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>patchflag的用途：</p>\n<ol>\n<li>用来标记当前节点需要更新，静态节点没有这个参数，更新的时候直接略过</li>\n<li>组合更新，比如：1-只更新显示文本，8-只更新属性，9-更新显示文本和属性</li>\n</ol>\n<p>在每次Dom更新的时候，只更新带有<code>patchflag</code>值的节点，没有的直接略过。而且，无论Dom节点层级有多深，都同样适用。这样更新只用关注变化的内容，而不用再去关心那些静态数据。这么做节省了更多的内存，提升更新渲染的速度。是不是很实用。</p>\n<p>其中值得提的一点，叫组合patchflag值。这种类型使用的是位运算的原理。举个例子说明一下：</p>\n<p><img src=\"https://p1.ssl.qhimg.com/t0154eed47f7ff06ff4.png\"></p>\n<p>图中，我们可以看到文本和属性的组合值，在按位与之后，就得到了patchflag值为9。其他同理，不做赘述。</p>\n<h2 id=\"静态提升\"><a href=\"#静态提升\" class=\"headerlink\" title=\"静态提升\"></a>静态提升</h2><h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"html-1\"><a href=\"#html-1\" class=\"headerlink\" title=\"html\"></a>html</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;span&gt;移动&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;端&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;流量&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;入口&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;&#123;&#123; vue3 &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;5G&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译结果\"><a href=\"#编译结果\" class=\"headerlink\" title=\"编译结果\"></a>编译结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const _hoisted_1 &#x3D; &#123; id: &quot;app&quot; &#125;</span><br><span class=\"line\">const _hoisted_2 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;移动&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\">const _hoisted_3 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;端&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\">const _hoisted_4 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;流量&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\">const _hoisted_5 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;入口&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\">const _hoisted_6 &#x3D; &#x2F;*#__PURE__*&#x2F;_createVNode(&quot;span&quot;, null, &quot;5G&quot;, -1 &#x2F;* HOISTED *&#x2F;)</span><br><span class=\"line\"></span><br><span class=\"line\">export function render(_ctx, _cache) &#123;</span><br><span class=\"line\">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class=\"line\">    _hoisted_2,</span><br><span class=\"line\">    _hoisted_3,</span><br><span class=\"line\">    _hoisted_4,</span><br><span class=\"line\">    _hoisted_5,</span><br><span class=\"line\">    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.vue3), 1 &#x2F;* TEXT *&#x2F;),</span><br><span class=\"line\">    _hoisted_6</span><br><span class=\"line\">  ]))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到所有的静态节点都被拿到了渲染函数之外，这样做的好处就是，静态节点只用被创建一次，在以后的渲染的时候拿来复用就行。可以极大的优化大型项目的内存占用，不用每次渲染都要重新创建。</p>\n<h2 id=\"事件监听缓存cacheHandlers\"><a href=\"#事件监听缓存cacheHandlers\" class=\"headerlink\" title=\"事件监听缓存cacheHandlers\"></a>事件监听缓存cacheHandlers</h2><p>我们知道在vue2中，针对节点绑定的事件，每次触发都要重新生成全新的function去更新，而React目前也没有去缓存事件，具体为什么不去做，不得而知。在vue3中，就做了这么一件事情。当cacheHandlers开启的时候，编译会自动生成一个内联函数，将其变成一个静态节点，相当于React中的useCallback。并且本身就支持手写内联函数，这点就比较方便。我们来看下代码示例：</p>\n<h3 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"html-2\"><a href=\"#html-2\" class=\"headerlink\" title=\"html\"></a>html</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;button @click&#x3D;&quot;confirmHandler&quot;&gt;确认&lt;&#x2F;button&gt;</span><br><span class=\"line\">  &lt;span&gt;&#123;&#123; vue3 &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"开启cacheHandlers\"><a href=\"#开启cacheHandlers\" class=\"headerlink\" title=\"开启cacheHandlers\"></a>开启cacheHandlers</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const _hoisted_1 &#x3D; &#123; id: &quot;app&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function render(_ctx, _cache) &#123;</span><br><span class=\"line\">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class=\"line\">    _createVNode(&quot;button&quot;, &#123;</span><br><span class=\"line\">      onClick: _cache[1] || (_cache[1] &#x3D; $event &#x3D;&gt; (_ctx.confirmHandler($event)))</span><br><span class=\"line\">    &#125;, &quot;确认&quot;),</span><br><span class=\"line\">    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.vue3), 1 &#x2F;* TEXT *&#x2F;)</span><br><span class=\"line\">  ]))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关闭cacheHandlers\"><a href=\"#关闭cacheHandlers\" class=\"headerlink\" title=\"关闭cacheHandlers\"></a>关闭cacheHandlers</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const _hoisted_1 &#x3D; &#123; id: &quot;app&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function render(_ctx, _cache) &#123;</span><br><span class=\"line\">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class=\"line\">    _createVNode(&quot;button&quot;, &#123; onClick: _ctx.confirmHandler &#125;, &quot;确认&quot;, 8 &#x2F;* PROPS *&#x2F;, [&quot;onClick&quot;]),</span><br><span class=\"line\">    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.vue3), 1 &#x2F;* TEXT *&#x2F;)</span><br><span class=\"line\">  ]))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以很清楚的看到其中的差别，开启cacheHandlers事件缓存之后，生成内联函数_cache，这样每次就不用重复渲染了，在事件更新频繁或者绑定事件过多的情况下，性能优化非常显著。</p>\n<h2 id=\"SSR\"><a href=\"#SSR\" class=\"headerlink\" title=\"SSR\"></a>SSR</h2><p>这个原理其实很简单，就是把所有的静态内容编译成一个字符串push到一个buffer里。</p>\n<h3 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"html-3\"><a href=\"#html-3\" class=\"headerlink\" title=\"html\"></a>html</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;button @click&#x3D;&quot;confirmHandler&quot;&gt;确认&lt;&#x2F;button&gt;</span><br><span class=\"line\">  &lt;span&gt;&#123;&#123; vue3 &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">  &lt;span&gt;vue&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译结果-1\"><a href=\"#编译结果-1\" class=\"headerlink\" title=\"编译结果\"></a>编译结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; ssrInterpolate as _ssrInterpolate &#125; from &quot;@vue&#x2F;server-renderer&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">export function ssrRender(_ctx, _push, _parent) &#123;</span><br><span class=\"line\">  _push(&#96;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;button&gt;确认&lt;&#x2F;button&gt;&lt;span&gt;$&#123;_ssrInterpolate(_ctx.vue3)&#125;&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;span&gt;vue&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#96;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是不是很神奇，我们看到所有的静态节点span全部被编译成了一个字符串，甚至里面的动态节点也被尽可能的字符化。这样做至少可以节省一半以上内存，总体渲染速度加快一倍以上。SSR服务端渲染在性能上，比单纯的抽成Virtual Dom去渲染，快的不是一个量级，两者完全不在一个层面上。</p>\n<p>这里要注意一点的是，如果静态节点数量很多，超过了一个阈值，vue3会单独创建一个div，将静态节点innerHTML到该div里去。</p>\n<h1 id=\"Tree-shaking\"><a href=\"#Tree-shaking\" class=\"headerlink\" title=\"Tree-shaking\"></a>Tree-shaking</h1><p>这里有很多解释，我更偏向于理解成，把没用的树叶”抖掉“这个比喻。</p>\n<p>换句话说，就是按需引入我们需要的模块。对于用不到的模块就不会打包。</p>\n<h3 id=\"代码-4\"><a href=\"#代码-4\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"html-4\"><a href=\"#html-4\" class=\"headerlink\" title=\"html\"></a>html</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;vue3&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"编译结果-2\"><a href=\"#编译结果-2\" class=\"headerlink\" title=\"编译结果\"></a>编译结果</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import &#123; vModelCheckbox as _vModelCheckbox, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">const _hoisted_1 &#x3D; &#123; id: &quot;app&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function render(_ctx, _cache) &#123;</span><br><span class=\"line\">  return (_openBlock(), _createBlock(&quot;div&quot;, _hoisted_1, [</span><br><span class=\"line\">    _withDirectives(_createVNode(&quot;input&quot;, &#123;</span><br><span class=\"line\">      type: &quot;checkbox&quot;,</span><br><span class=\"line\">      &quot;onUpdate:modelValue&quot;: $event &#x3D;&gt; (_ctx.vue3 &#x3D; $event)</span><br><span class=\"line\">    &#125;, null, 8 &#x2F;* PROPS *&#x2F;, [&quot;onUpdate:modelValue&quot;]), [</span><br><span class=\"line\">      [_vModelCheckbox, _ctx.vue3]</span><br><span class=\"line\">    ])</span><br><span class=\"line\">  ]))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里在编译阶段，仅仅引入了vModelCheckbox一个Dom相关模块，其他模块都是通用的必须要引入的。这样打出的包会体积更小，速度更快，性能更好。这一点在vue2里是没有做区分的。</p>\n<h1 id=\"Composition-API\"><a href=\"#Composition-API\" class=\"headerlink\" title=\"Composition API\"></a>Composition API</h1><p>终于到了vue3.0版本里最重磅的内容。与React Hooks类似，只是实现方式，整体气质不同。</p>\n<p>拥有以下特性</p>\n<ul>\n<li>兼容现有的Options API，无缝衔接</li>\n<li>更加灵活，组合更方便，复用性更强</li>\n<li>可以跟其他框架搭配使用</li>\n</ul>\n<p>我们知道，vue3采用RFC来讨论所有的API的实现，并且把所有讨论的细节都呈现给使用者，我觉得这点是非常棒的事情。可以更友好的让开发者理解和学习API的使用，附上文档学习地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21wb3NpdGlvbi1hcGkudnVlanMub3JnLyNzdW1tYXJ5\">https://composition-api.vuejs.org/#summary<i class=\"fa fa-external-link-alt\"></i></span>。</p>\n<p>那么，为什么vue3必须要有Composition API这样的东西呢？下面我们看下几个场景，你就能理解Composition API的强大了。</p>\n<h2 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h2><p><img src=\"https://p2.ssl.qhimg.com/t01ea41ae7d0a1b93c5.png\"></p>\n<p>图中我们可以看到在解决API复用上，Mixin是可以达到的。但是它最要命的就是命名空间冲突的问题，这个缺陷可以导致代码的不可维护，这点对于开发者是不能接受的，甚至毁灭性的。</p>\n<h2 id=\"Scoped-Slots\"><a href=\"#Scoped-Slots\" class=\"headerlink\" title=\"Scoped Slots\"></a>Scoped Slots</h2><p><img src=\"https://p0.ssl.qhimg.com/t01adf14597d4f2bd21.png\"></p>\n<p>Scoped Slots虽然可以解决Mixin的问题，但是它的问题就是配置太多，逻辑也太多，这样就导致它的复用性和灵活性极差，还不如Mixin。</p>\n<p>最后，我们来看看Composition API是怎么实现的。</p>\n<h2 id=\"Composition-Functions\"><a href=\"#Composition-Functions\" class=\"headerlink\" title=\"Composition Functions\"></a>Composition Functions</h2><p><img src=\"https://p2.ssl.qhimg.com/t01b41cd8e633003da5.png\"></p>\n<p>是不是很棒，使用了我们熟悉的函数式编程，结构非常清晰，代码量也减少了很多，最重要的是灵活性和复用性很友好。也不用担心会命名冲突的问题。</p>\n<h3 id=\"组件中的使用\"><a href=\"#组件中的使用\" class=\"headerlink\" title=\"组件中的使用\"></a>组件中的使用</h3><p><img src=\"https://p1.ssl.qhimg.com/t01c66ed230f8a7ef3f.png\"></p>\n<p>图中不同颜色代表不同逻辑的业务代码，相同颜色表示同一业务需要的代码。我们在写一个比较复杂的组件的时候，有没有这种体会。组件里面包含很多个小的功能组件，这些功能可能在其他页面也有用到，但是数据强依赖这个组件的接口。所以只能分开，单独写到这个组件里，导致组件代码又臭又长，还没法复用。遇到这种情况，我们也只能望洋兴叹。在vue3.0出来之后，我们就可以完美的解决这种问题。我们可以任意在同一组件里，写不同的业务逻辑，不仅层次分明，逻辑清楚，而且神奇的是，你可以信手拈来，拿去复用在其他组件里。你可能也不再需要为了一个页面，去封装十几个小组件了。费神费力，还容易出错。</p>\n<p>使用Composition API写出的代码，后期筛查问题、维护和update上，体验也是极度舒适的。</p>\n<p>当然，我们不用担心之前的Options API不能用，vue3做了兼容，可以一起使用的。建议有了它就不要再考虑使用其他方案了。</p>\n<p>具体使用方法可以查看文档：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21wb3NpdGlvbi1hcGkudnVlanMub3JnLyNzdW1tYXJ5\">https://composition-api.vuejs.org/#summary<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h1 id=\"Fragments\"><a href=\"#Fragments\" class=\"headerlink\" title=\"Fragments\"></a>Fragments</h1><p>碎片，这个我理解是不再限制组件中必须提供根节点。你可以这么写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;vue3&lt;&#x2F;div&gt;</span><br><span class=\"line\">text</span><br></pre></td></tr></table></figure>\n\n<p>也可以这么写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vue3</span><br></pre></td></tr></table></figure>\n\n<p>其实看编译的代码，你会发现，vue3只是帮你生成了一个根节点来包裹。这么做的好处就是你省事了，腾出手来做你喜欢做的，vue3就像你的爱人一样，默默地帮你做了许多。</p>\n<h1 id=\"Teleport\"><a href=\"#Teleport\" class=\"headerlink\" title=\"Teleport\"></a>Teleport</h1><p>这个特性，我理解相当于”占位“。看下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- 占位，专门用来显示定制内容 --&gt;</span><br><span class=\"line\">&lt;div id&#x3D;&quot;modal-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 父页面 --&gt;</span><br><span class=\"line\">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    </span><br><span class=\"line\">    &lt;!-- 调用Teleport --&gt;</span><br><span class=\"line\">    &lt;Teleport to&#x3D;&quot;#modal-container&quot;&gt;</span><br><span class=\"line\">        &lt;div v-show&#x3D;&quot;isPopUpOpen&quot;&gt;</span><br><span class=\"line\">          &lt;p&gt;确定删除？&lt;&#x2F;p&gt;</span><br><span class=\"line\">          &lt;button @click&#x3D;&quot;removeUser&quot;&gt;确定&lt;&#x2F;button&gt;</span><br><span class=\"line\">          &lt;button @click&#x3D;&quot;isPopUpOpen &#x3D; false&quot;&gt;取消&lt;&#x2F;button&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;Teleport&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里，id是modal-container的模块会在根页面里占位，在调用的时候插入<Teleport></Teleport>模块。这么做可以避免由于z-index层级问题导致的显示异常。</p>\n<p>我认为这个特性不仅仅这么简单，其他应用场景有待挖掘。</p>\n<h1 id=\"Suspense\"><a href=\"#Suspense\" class=\"headerlink\" title=\"Suspense\"></a>Suspense</h1><p>翻译为，”悬念“。我理解就是异步加载依赖。</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><ul>\n<li>可在嵌套层级中等待嵌套的异步依赖项</li>\n<li>支持 async setup()</li>\n<li>支持异步组件</li>\n</ul>\n<h3 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; vue2实现</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        &lt;div v-if&#x3D;&quot;!loading&quot;&gt;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">        &lt;div v-if&#x3D;&quot;loading&quot;&gt;Loading...&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; vue3实现</span><br><span class=\"line\">&lt;Suspense&gt;</span><br><span class=\"line\">  &lt;template&gt;</span><br><span class=\"line\">    &lt;Suspended-component &#x2F;&gt;</span><br><span class=\"line\">  &lt;&#x2F;template&gt;</span><br><span class=\"line\">  &lt;template #fallback&gt;</span><br><span class=\"line\">    Loading...</span><br><span class=\"line\">  &lt;&#x2F;template&gt;</span><br><span class=\"line\">&lt;&#x2F;Suspense&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这里实现一个过渡效果，使用Suspense实现，更简单直接一些。</p>\n<p>这个特性的应用场景，也可能是图片或者模块的顺序加载。对于业务逻辑比较复杂，需要异步加载静态节点的时候，可以考虑使用。</p>\n<h1 id=\"Custom-Renderer-API\"><a href=\"#Custom-Renderer-API\" class=\"headerlink\" title=\"Custom Renderer API\"></a>Custom Renderer API</h1><p>自定义渲染API这块，意味着以后我们可以通过 vue ，实现用 dom 编程的方式来进行 webgl 编程。</p>\n<p>其他的一些变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 周期函数变化</span><br><span class=\"line\"></span><br><span class=\"line\">被替换</span><br><span class=\"line\"></span><br><span class=\"line\">beforeCreate -&gt; setup()</span><br><span class=\"line\">created -&gt; setup()</span><br><span class=\"line\"></span><br><span class=\"line\">重命名</span><br><span class=\"line\"></span><br><span class=\"line\">beforeMount -&gt; onBeforeMount</span><br><span class=\"line\">mounted -&gt; onMounted</span><br><span class=\"line\">beforeUpdate -&gt; onBeforeUpdate</span><br><span class=\"line\">updated -&gt; onUpdated</span><br><span class=\"line\">beforeDestroy -&gt; onBeforeUnmount</span><br><span class=\"line\">destroyed -&gt; onUnmounted</span><br><span class=\"line\">errorCaptured -&gt; onErrorCaptured</span><br><span class=\"line\"></span><br><span class=\"line\">新增的</span><br><span class=\"line\"></span><br><span class=\"line\">新增的以下2个方便调试 debug 的回调钩子：</span><br><span class=\"line\"></span><br><span class=\"line\">onRenderTracked</span><br><span class=\"line\">onRenderTriggered</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 对应的自定义指令变化</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; vue2</span><br><span class=\"line\">const MyDirective &#x3D; &#123;</span><br><span class=\"line\">  bind(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\">  inserted() &#123;&#125;,</span><br><span class=\"line\">  update() &#123;&#125;,</span><br><span class=\"line\">  componentUpdated() &#123;&#125;,</span><br><span class=\"line\">  unbind() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; vue3</span><br><span class=\"line\">const MyDirective &#x3D; &#123;</span><br><span class=\"line\">  beforeMount(el, binding, vnode, prevVnode) &#123;&#125;,</span><br><span class=\"line\">  mounted() &#123;&#125;,</span><br><span class=\"line\">  beforeUpdate() &#123;&#125;,</span><br><span class=\"line\">  updated() &#123;&#125;,</span><br><span class=\"line\">  beforeUnmount() &#123;&#125;, &#x2F;&#x2F; new</span><br><span class=\"line\">  unmounted() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"更好的TypeScript支持\"><a href=\"#更好的TypeScript支持\" class=\"headerlink\" title=\"更好的TypeScript支持\"></a>更好的TypeScript支持</h1><p>vue3.0版本里，采用了TypeScript重写，意味着之后会全面拥抱TypeScript。类型提示、检测都更加的友好强大。废弃了Class，如果你还是喜欢Class的用法，可以安装单独库vue-class-component支持。</p>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>以上对vue3主要的新特性做了简单的总结，也加入了一些个人的理解，目前还不能放手使用，只能算尝鲜阶段，所以如果想更深入了解，要仔细研读下vue3的源码。尤大大在直播问答环节，表示可能需要年终才会发布正式版本，所以还有一段时间来完善框架，让vue3更饱满的呈现给众人。后续还需要做的工作主要包括，文档编写，完善开发者工具，以及自动化迁移工具等。有大量的工作要做，是为了给vue2升级vue3做准备。尤大大在直播中也提及，未来会有一个过渡版本发布，这也是最后一个vue2版本vue2.7，计划在不损坏兼容性的前提下，加入一些好的vue3的功能，把它们提前合并入2.7版本，提供给开发者使用体验。而在这之后18个月，表示只会进行安全性的描述，不在继续维护。</p>\n<p>而关于vue2升级到vue3，作者也友情提示大家，对于业务逻辑偏重的项目，请一定酌情考虑升级，自觉规避风险，言下之意就是说在全面拥抱vue3之前，可能你需要做一些取舍。</p>\n<p>最后，我猜想，Composition API是有极大可能提前加入到2.7版本，提前让大家体验，那就让我们敬请期待吧。</p>\n","categories":["前端"],"tags":["Vue3"]}]